cquestions:
what is system call? what happen in low level? how to implement your own system call?

	1. In kernel, each system call is identified by a number.
	2. When system call is called, first it calls the C lib wrapper function. This function place all the required information in the CPU 
		registers. i.e. in case of x86 0x80 INT and in case of ARM, R7 is placed with the system call id no.
	3. After this, Software interrupt (SWI) is generated to switch the context from user to kernel space.
	4. Now the process is in kernel mode, trap handler is called, system_call() to handle this.
	5. Trap handler copied all the information from CPU register to kernel stack. It validates the information. It gets the required system call 
		routine from sys_call_table().
	6. After serving the actual system call, control is returned back to trap handler, and from there to user space.

what call back functions? how to share function pointer b/w two process?

How can you avoid accessing of an array beyond its limits?

In a big array consists of 1's & 0's ,write an efficient programe to keep all 1's to right side and 0's to other side

In a Process Address Space what if stack or heap collide?

What is shared lib and static library? And how to create it ?

Difference between #define and CONST, which one will you chose in programming?

tell me the logic how can you find depth of a stack?

difference b/w macro and a constant variable?

What is structure padding,alignment and packing.?

How to write own malloc call?

What is the difference between inline and macro?

How to know size of memory allocated by malloc using pointer?

How does free() know that this much memory it need to free?

how to free the memory without using free() system call?

Bitwise:

How to set particular bit in a number? 
#define SET_BIT(Number, bit_position)    		Number |=  (1<< bit_position)
OR

Write a program to set n th bit in 32 bit number?
	int setbit(int num, int pos)
	{
			   num = num | 1 << pos;
	}

How to clear particular bit in a number? 
#define CLEAR_BIT(Number, bit_position)    		Number &= ~(1<< bit_position)

How to toggle or flip particular bit in a number?
#define TOGGLE_BIT(Number, bit_position)    		Number ^=  (1<< bit_position) 

How to check particular bit is set or not in a number?
#define CHECK_BIT_IS_SET_OR_NOT(Number, bit_position)   Number & (1<< bit_position)

Write a program to count total number of setbit in 32 bit number?
	
	int countset(int num)
	{
			   int count = 0;
			   while (num) {
					if( ((num) & 1) == 1)
					   count++;
					 num = num >> 1;
				  }
				 return count;
	}
	or
	unsigned int countsetbit(int num)
	{
			   int count = 0;
			   while(num != 0) {
					count ++;
					num = num & (num-1);
				  }
				 return count;
	}
	or
	while(n)
	{
		n = n&(n-1);
		count ++;
	}
	OR
	int count_set_bits (long n)
	{
		return (n ? 1+ count_set_bits (n&n-1) : 0);
	} 

Write a program to find number is even or odd?
	void evnodd(int num)
	{
		   if( (num) & (1) )
			   printf("odd");
		  else
			   printf("even");
	} 

C program to swap every 2 bits in a 8 bit binary number?

How would you obtain n bits from position p in an integer?
	First left shift 32-p bits followed by 32-n bits right shift.
	/* getbits: get n bits from position p */ 
	unsigned getbits(unsigned x, int p, int n) { 
		return (x >> (p+1-n)) & ~(~0 >(p+1-n)
	}	 
	moves the desired field to the right end of the word. ~0 is all 1 bits; 
	shifting it left n bit positions with ~0 << n places zeros in the rightmost n bits; complementing that with ~ makes a mask 
	with ones in the rightmost n bits. Directly from K&R.
	
Write a code to extract nth to mth bit, where n?
	(num >> n) & ~(~ 0 << (m-n+1))

write a code for toggling nth to m bits,where n < m?
	num ^ ((~ 0 << n) & ( ~0 >> (31-m)))

Write a code for setting nth to mth bit, where n < m?
	num | ((~0 << n) & (~0 >>(31-m)))
	
write a code for clearing nth to mth bit, where n  < m?
	num & ~((~0 << n) & (~0 >> (31-m))) 

Explain about container_of() and offsetof() implementations.

Count strings with consecutive 1's

Sum of Bitwise And of all pairs in a given array

Write a program to add one to a given number. You are not allowed to use airtmatic operators ?

Multiply two integers without using multiplication, division and bitwise operators, and no loops?

Check if a number is a power of another number

Check perfect square using addition/subtraction

Write an Efficient C Program to Reverse Bits of a Number

Byte Swap program?
	function swap16(val) { 
		return ((val & 0xFF) << 8) | ((val >> 8) & 0xFF); 
		}

	function swap32(val) { 
		return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) | ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF); 
		}

Write a program to swap nibble of a 1byte data?
	int main( void )
	{
	  unsigned char a = 40, b=20;
	  a = ( a>>4 ) | ( a<<4 );
	  b = ( ( b & 0xAA ) >> 1 ) | ( ( b & 0x55 ) << 1 );
	  return 0;
	}

Portable way to obtain the most significant byte?
	(a) i & 0xFF00 
	(b) i >> 24 
	(c) i & 0xFF000000 
	(d) i >> (CHAR_BIT * sizeof(int) - 1))

	(a)-(c) does not cover sizeof(int),
	d) is comprehensive because of CHAR_BIT (some implementation has 7 bits for char), sizeof(int)(4,8,16 byte int), 
	and right shift works regardless of Endianness (it always shift bits towards least significant). 

How to swap between first & 2nd byte of an integer in one line statement?
	int x=0x1234;
	x = x<<8 | x>>8;

Write a program to find number is power of 2 or not?
	void  power(int num)
	{
		   if( !( (num) & (num-1) ) )
			   printf("power of 2");
		  else
			   printf("num is not power of 2");
	} 
Note: The logic says that if a no. is power of 2, then in the binary representation, only one bit of the no. can be set.

write a C program to swap even and odd bits of a given number?
	#include
	unsigned int swapBits(unsigned int x)
	{
		// Get all even bits of x
		unsigned int even_bits = x & 0xAAAAAAAA;
		// Get all odd bits of x
		unsigned int odd_bits  = x & 0x55555555;
		even_bits >>= 1;  // Right shift even bits
		odd_bits <<= 1;   // Left shift odd bits
		return (even_bits | odd_bits); // Combine even and odd bits
	}
	OR	
	unsigned int swap_bits(unsigned int num)
	{
	  return (num >> 1 & 0x55555555) | (num << 1 & 0xAAAAAAAA);
	}

Write a function to swap odd bits in a number? e.g. b1 swapped with b3, b5 swapped with b7 and so on.
	unsigned int swap_odd_bits(unsigned int num)
	{
	 return (num >> 2 & 0x22222222) |
			 (num << 2 & 0x88888888) |
			 ( num   & 0x55555555) ; 
	}

Write a function to swap even bits in a number?
	e.g. b0 swapped with b2, b4 swapped with b6 and so on.
	unsigned int swap_even_bits(unsigned int num)
	{
	  return (num >> 2 & 0x11111111) |
			 (num << 2 & 0x44444444) |
			 ( num   & 0xAAAAAAAA);}

Write a function for finding the first lowest bit set in a number.
	unsigned int first_lowest_bit(unsigned num)
	{
	 int count =0;
	 while(num) {
	  count ++;
	  if( (num) & 1 == 1)
	   break;
	  num = num >> 1;
	 }
	 return count;
	}

Write a function for finding the higest bit set in a number.
	unsigned int first_highest_bit(unsigned num)
	{
	 int count =0;
	 while(num) {
	  count ++;
	  if( (num & (1 << 31) ) == 1)
	   break;
	  num = num << 31;
	 return count;
	}

Write a function for reversing the bits in a number.
	unsigned int reverse_bit(unsigned num)
	{
	 unsigned int NO_OF_BITS = sizeof(num) * 8;
	 unsigned int temp,rev=0;
	 for(i=0; i <= NO_OF_BITS -1 ;i++) {
	  if(temp) {
	   rev |= (1 << ((NO_OF_BITS-1)-i);
	 }
	 return rev;
	}

swap two variable without temp variable ?
	/* swapping using three variables*/ (Takes extra memory space)
	Int a=5, b=10, c;
	c=a; a=b; b=c;

	/* using arithmetic operators */
	a=a+b; b=a-b; a=a-b;

	/* using bit-wise operators */
	a=a^b; b=b^a; a=a^b;
	
	/* one line statement using bit-wise operators */ (most efficient)
	a^=b^=a^=b;
	The order of evaluation is from right to left. This is same as in approach (c) but the three statements are compounded into 
	one statement.

	/* one line statement using arithmetic & assignment operators */
	a=(a+b) - (b=a);
	In the above axample, parenthesis operator enjoys the highest priority & the order of evaluation is from left to right. 
	Hence (a+b) is evaluated first and replaced with 15. 
	Then (b=a) is evaluated and the value of a is assigned to b, which is 5. Finally a is replaced with 15-5, i.e. 10. Now the two 		numbers are swapped.

How to reverse a string with out using Temporary variable?
	#include<stdio.h>
	#include<string.h>

	#define LEN 100 /* Can be changed */
	int main()
	{
	   char str[LEN];   
	   unsigned int end, start=0;

	   printf(" Enter the String to be reversed  \n");
	   scanf("%s", str);

	   /* Find out the string Length */
	   end = strlen(str)-1;
	   /* Iterate through start less than end */
	   while(start < end)  
	   {
	     str[start]   ^= str[end];
	     str[end]     ^= str[start];
	     str[start]   ^= str[end];
	    
	     start++;
	     end --;
	   }
	   printf("The Reverse string is : %s\n", str);
	   return 0;
	}

linklist:
	kfifo:
	http://elixir.free-electrons.com/linux/latest/source/samples/kfifo/bytestream-example.c
	https://lwn.net/Articles/102951/
	https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/samples/kfifo/dma-example.c
	https://lwn.net/Articles/347619/

Write a program for a singly linked list, doubly linked list, circular singly linked list, circular doubly linked list 
	(insert, delete, count, search etc functions).

implement Stack and Queue using Linked List?

Arrange elements in single linked list in odd-even group?

Reverse a singly linked list? Reverse a Linked List using Recursion?

You are given a pointer to a node (not the tail node) in a singly linked list. Delete that node from the linked list?

Repeatedly Delete N nodes after M nodes of a Linked list?

find and Remove Duplicates node from a Linked List ?

Move last node to front in linked list?

Swap every two nodes in a linked list?

Frequency of a given number in a Linked List?

Rotate linked list by K nodes?

Finding middle of the single linked list in a single traversal?

	Step 1:
	Take two pointers P1 and P2, both pointed to the first element.
	Step 2:
	Increment P1 by 1 and P2 by two.
	Step 3:
	Whenever P2 reaches to the end, P1 will be at the middle of the list, just return P1->data.

Write a C function to print the middle of a given linked list.
	struct node {
		int data;
		struct node *next;
	};

	void findmiddle(struct node *head)
	{
		struct node * slow = head;
		struct head * fast = head;
		while (fast != NULL && fast->next != NULL) {
			slow = slow->next;
			fast = slow->next->next;
		}
		printf(" Middle element is %d\n", slow->data);
	}

Write a c program to get the intersection point of two singly linked lists.
	struct node {
		int data;
		struct node *next;
	};

	struct node * head = NULL:

	int count_node(struct node * head)
	{
		int count = 0;
		struct node * current = head;
		while (current != NULL) {
			count ++;
			current = current->next;
		}
		return count;
	}

	struct get_intersection_mod(int d,struct node * head1, struct node * head2)
	{
		struct node current1 = head1;
		struct node current2 = head2;
	   
		for(i=0;i        cureent1 = current->next;
		}
		while(cuttent1 != NULL && current2 != NULL) {
			if(current1 == current2) {
				printf(" intersection node =%d\n", current1->data);
				break;
			}
			current1 = current1->next;
			current2 = current2->next;
		}
	}

	void get_intersecton(struct node * head1, struct node * head2)
	{
		struct node *current = head1;
		struct node *current = head2;
		int c1, c2;
		c1 = count_node(current1);
		c2 = count_node(current2);
		if(c1 > c2) {
			d= c1 -c2;
			get_intersection_mod(d,head1,head2);
		}
		else {
			d = c2 -c1;
			get_intersection_mod(d, head1,head2);
		}
	}

find length of circular linked list given a pointer to some node of linkedlist?

Finding a linked list that is either circular or not circular ?
	Try using 2 pointers:
	pointers travelling at different speeds start from the 
	head of the linked list
	Iterate through a loop
	If the faster pointer reaches a NULL pointer then return
	saying that the list is acyclic and not circular
	If the faster pointer is ever equal to the slower pointer or the
	faster pointer's next pointer is ever equal to the slower pointer
	then return that the list is circular

	Advance the slower pointer one node
	Advance the faster pointer by 2 nodes

	Tortoise and hare(rabbit) algorithm:
	The above pseudo code is called Tortoise and rabbit algorithm

	bool findCircular(Node *head)
	{
	   Node *slower, * faster;
	   slower = head;
	   faster = head->next; //start faster one node ahead
	   while(true) {
	   
		 // if the faster pointer encounters a NULL element
		 if( !faster || !faster->next)
		   return false;
		//if faster pointer ever equals slower or faster's next
		//pointer is ever equal to slow then it's a circular list
		 else if (faster == slower || faster->next == slower)
			return true;
		 else{
		   // advance the pointers
			slower = slower->next;
			faster = faster->next->next;
		  }
	   }
	}

	OR
	struct node {
		int data;
		struct node *next;
	};

	struct node *head = NULL:

	void detectloop(struct node * head)
	{
		struct node * slow = head;
		struct node * fast = head;
		while(slow && fast && fast->next) {
			slow = slow->next;
			fast = fast->next->next;
			if (slow == fast) {
				printf("Loop detected\n');
				break;
			}
		}
	}

Write a C program to return the nth node from the end of a linked list

Array vs Linked list?
	Major differences between arrays and linked lists are: 
	(i)  In array consecutive elements are stored in consecutive memory locations whereas in linked list it not so. 
		  Array Elements are stored in contiguous memory locations. Hence they will be faster to retrieve.
	(ii)  In array address of next element is consecutive and whereas in linked list it is specified in the address part of each node.
	(iii) Linked List makes better use of memory than arrays.(iv) Insertion or deletion of an element in array is difficult than 			insertion or deletion in linked list.
	
Find the size of a structure with out size of operator.

why stack is always in higher location.

what is the difference between global and static

have u debug any issues using jtag/ any other debugger.if yes, how can we get the call stack in the debugger.

Write a function to find whether machine is little endian or big endian.?

Write a program to find occurrence of particular key in given string?

write a program to move all 0's to one side and 1's on ther side of array?

Write a program to find largest element in an array?

Write a program to find second largest element from array?

Write a program to find weather machine is 32 bit or 64 bit?

What is memory leakage? How can we avoid it?

What is NULL , void, dangling pointer?

Can we use const keyword with volatile variable?

Compilation How to reduce a final size of executable?

What is the purpose of main( ) function ?
	The function main( ) invokes other functions within it.It is the first function to be called when the program starts execution.
	\B7 It is the starting function
	\B7 It returns an int value to the environment that called the program
	\B7 Recursive call is allowed for main( ) also.
	\B7 It is a user-defined function
	\B7 Program execution ends when the closing brace of the function main( ) is reached.
	\B7 It has two arguments 1)argument count and 2) argument vector (represents strings passed).
	\B7 Any user-defined name can also be used as parameters for main( ) instead of argc and argv

Is using exit() the same as using return?
	No. The exit() function is used to exit your program and return control to the operating system. The return statement is used to 
	return from a function and return control to the calling function.

What is the output of printf("%d") ?
	When we write printf("%d",x); this means compiler will print the value of x. But as here, there is nothing after %d so compiler 
	will show in output window garbage value.

Typecast when to use and when not to use? implicit and explicit typecasting ?

What does the following code output and why?
	void foo(void) {
		unsigned int a = 6;
		int b = -20;
		(a +b > 6) ? puts(">6") : puts("<6");
	}

Switch vs if; which one is better? Why?
	A switch statement is generally best to use when you have more than two conditional expressions based on a single variable of numeric type.

for(i = 0; i < 5; i++) {} vs for(i = 5; i > 0; i--) {} whichone is faster?

Differentiate between a for loop and a while loop? What are it uses?
	For executing a set of statements fixed number of times we use for loop while when the number of
	iterations to be performed is not known in advance we use while loop.

What are differences between sizeof operator and strlen function?
	sizeof is keyword of c which can find size of a string constant including null character but strlen is function which has been 
	defined string.h and can find number of characters in a string excluding null character.

Write a code for String reverse, strlen, reverse words in a string, find duplicates in an array etc. ?

Little endian vs big endian? Why it is required? Which one is better? How the conversion happens? White a pseudo code for hton() and ntoh()?
	#include <stdio.h>
	int main() 
	{
		unsigned int i = 1;
		char *c = (char*)&i;
		if (*c)    
			printf("Little endian");
		else
			printf("Big endian");
		getchar();
		return 0;
	}

	void main ()
	{
		int x = 300;
		if ((* ((unsigned char *) & x) == 1)&& (*(unsigned char*) & x+1) == 44))
			printf (\93BIG ENDIAN\94);
		else
			printf (\93LITTLE ENDIAN\94);
	}

	void main ()
	{
		union xxx
		{
			unsigned int x;
			unsigned char ch[2];
		};
		union xxx p = {300};
		if ((p.ch [0] = = 1) && (p. ch [1] == 44))
			printf (\93BIG ENDIAN\94);
		else
			printf (\93LITTLE ENDIAN\94);
	}

How to reduce function call overhead in ARM based systems?
	Try to ensure that small functions take four or fewer arguments. These will not usethe stack for argument passing. 
		It will copied into registers.\B7 
	If a function needs more than four arguments, try to ensure that it does asignificant amount of work, so that the cost of passing 
		the stacked arguments isoutweighed.
	Pass pointers to structures instead of passing the structure itself.
	Put related arguments in a structure, and pass a pointer to the structure tofunctions. This will reduce the number of parameters 
		and increase readability.
	Minimize the number of long long parameters, as these take two argument words.This also applies to doubles if software 
		floating-point is enabled.
	Avoid functions with a parameter that is passed partially in a register and partiallyon the stack (split-argument). 
		This is not handled efficiently by the currentcompilers: all register arguments are pushed on the stack.
	Avoid functions with a variable number of parameters. Varargs functions

Write a program in C to add two numbers without using any maths operator (+, -, /, *).

How to print number from 1 to 100 without using conditional operators.
	void main ()
	{
		int  i=0;
		while (100 \96 i++)
		printf (\93 %d\94, i);
	}

WAP to print 100 times "Hello" without using loop & goto statement.
	void main()
	{
		show (1, 100);
	}
	show (int x, int y)
	{
		if (x>=y)
			return;
		printf (\93\n Hello\94);
		show (x+1, y);
	}
	i.e. Recursive function

Preprocessor:
Using the #define statement, how would you declare a manifest constant that returns the number of seconds in a year? Disregard leap years in your answer?
	#define SECONDS_PER_YEAR (60UL * 60UL * 24UL * 365UL)

Write the standard MIN macro. That is, a macro that takes two arguments and returns the smaller of the two arguments?
	#define MIN(A,B)       ((A) <=  (B) ? (A) : (B))

What is the purpose of the preprocessor directive #error?
	Either you know the answer to this, or you don't. If you don't, then see reference 1. This question is very useful for differentiating between normal folks and the nerds. 
	It's only the nerds that actually read the appendices of C textbooks that find out about such things.  Of course, if you aren't looking for a nerd, the candidate better hope she doesn't know the answer.

Where are macros stored in the memory? 
	Macros aren't stored anywhere separately. They get replaced by the code even before compilation.
	The compiler is unaware of the presence of any macro. If the code that replaces macro is large then the program size 
	will increase considerably due to repetition.

write a program to find sizeof structure without using size of operator?
	#define SIZEOF(var)     ( (char*)(&var+1) - (char*) (&var))
	int main()
	{
			struct s {
					int a;
					char b;
					int c;
			};
			struct s obj[1];
		printf("size of = %ld\n", SIZEOF(obj));
		return 0;
	}

Why is sizeof('a') not 1? what this mean sizeof(a++) ?

Advantages and disadvantages of using macro and inline functions?
	inline :A: 
	The ARM compilers support inline functions with the keyword __inline. This results ineach call to an inline function being substituted by its body, instead of a normal call. This
	results in faster code, but it adversely affects code size, particularly if theinline function islarge and used often.

#define vs #include?

#define vs typedef?  
Consider the two statements below and point out which one is preferred and why?
	#define dPS struct s *
	typedef struct s * tPS;

	dPS p1,p2; => struct s * p1, p2; 
	tPS p3,p4; => struct s * p1,struct s * p2;

What is the use of typedef?
	i)It increases the portability.
	(ii) It simplify the complex declaration and improve readability of the program.

What are macros? What are its advantages and disadvantages?
	Macro is a Pre-processor.Major advantage of using the macro is to increase the speed of the execution of the program.
	Major disadvantage of the macros are:
		(i) No type checking is performed in macro. This may cause error.
	(ii)  A macro call may cause unexpected results.

#define vs enum; Which one is better? And Why?
	The use of an enumeration constant (enum) has many advantages over using the traditional symbolic constant style of #define. 
	These advantages include a lower maintenance requirement, improved program readability, and better debugging capability.
	1) The first advantage is that enumerated constants are generated automatically by the compiler. Conversely, symbolic 
		constants must be manually assigned values by the programmer.
	2) Another advantage of using the enumeration constant method is that your programs are more readable and thus can be understood 
		better by others who might have to update your program later.
	3) A third advantage to using enumeration constants is that some symbolic debuggers can print the value of an enumeration constant. 
		Conversely, most symbolic debuggers cannot print the value of a symbolic constant. 
		This can be an enormous help in debugging your program, because if your program is stopped at a line that uses an enum, 
		you can simply inspect that constant and instantly know its value. 
		On the other hand, because most debuggers cannot print #define values, you would most likely have to search for that value 
		by manually looking it up in a header file.
	4)enum actually declares a type, and therefore can be type checked.

What is the purpose of the preprocessor directive #error?
	Preprocessor error is used to throw a error message during compile time. We can check the sanity of the make file and using debug options given below

	#ifndef DEBUG
	#ifndef RELEASE
	#error Include DEBUG or RELEASE in the makefile
	#endif
	#endif

write a MACRO to set the MSB?

#define cat(x,y) x##y concatenates x to y. But cat(cat(1,2),3) does not expand but gives preprocessor warning. Why?
	The cat(x, y) expands to x##y. It just pastes x and y. But in case of cat(cat(1,2),3), it expands to cat(1,2)##3 instead of 1##2##3. That is why it is giving preprocessor warning.

Infinite loops often arise in embedded systems. Howe does one code an infinite loop in C?
	while(1), for(;;)

	loop
	...
	goto loop

what are Static and Dynamic Libraries? advantage and disadvantages of both?

What is the difference between static linking and dynamic linking ?
	http://www.bogotobogo.com/cplusplus/libraries.php
	In static linking, all the library modules used in the program are placed in the final executable file making it larger in size.
	This is done by the linker. 

	If the modules used in the program are modified after linking, then re-compilation is needed. 
	The advantage of static linking is that the modules are present in an executable file. We don't want to worry about 
	compatibility issues.

	In case of dynamic linking, only the names of the module used are present in the executable file and the actual linking is done 
	at run time when the program and the library modules both are present in the memory.

	That is why, the executables are smaller in size. Modification of the library modules used does not force re-compilation. 
	But dynamic linking may face compatibility issues with the library modules used.

What is the difference between #include "..." and #include <...>?
		The difference lies in where the preprocessor looks for the file to be included. For the include directive with a double quoted filename, 
		the preprocessor limits its search for the file to the same directory where the current source file resides. On the other hand, 
		when the directive uses angle brackets, the preprocessor searches for the file in directories pre-designated by the compiler - usually directories where standard library header files reside.

What is the benefit of using #define to declare a constant?
	Using the #define method of declaring a constant enables you to declare a constant in one place and use it throughout your program. 
	This helps make your programs more maintainable, because you need to maintain only the #define statement and not several instances 
	of individual constants throughout your program.
	For instance, if your program used the value of pi (approximately 3.14159) several times, you might want to declare a constant for 
	pi as follows:  #define PI 3.14159
	Using the #define method of declaring a constant is probably the most familiar way of declaring constants to traditional C programmers. 
	Besides being the most common method of declaring constants, it also takes up the least memory.
	Constants defined in this manner are simply placed directly into your source code, with no variable space allocated in memory. 
	Unfortunately, this is one reason why most debuggers cannot inspect constants created using the #define method
		
storge class:
what is qualifiers?   
	Qualifiers defines the property of the variable. Two qualifiers are const and volatile. The const type qualifier declares an object to be unmodifiable. 
	The volatile type qualifier declares an item whose value can legitimately be changed by something beyond the control of the program in which it appears, such as a concurrently executing thread / interrupt routine. 

Can static variables be declared in a header file?
	you can\92t declare a static variable without defining it as well (this isbecause the storage class modifiers static and extern are mutuallyexclusive). 
	A static variable can be defined in a header file, but thiswould cause each source file that included the header file to have its  own private copy of the variable, which is probably not what wasintended.
	
Can a static variable accessed from outside of the file?

What is volatile variable means?
	volatile has nothing to deal with storage class.
	volatile just tells the compiler or force the compiler to "not to do the optimization" for that variable. so compiler would not optimize 
	the code for that variable and reading the value from the specified location, not through interal register which holds the previous value.
	So, by declaring variable as volatile.. it gives garrantee that you will get the latest value, which may be alterred by an external event.
	your code may be work fine if haven't declare that variable as volatile, but there may be chance of not getting correct value sometimes.. 
	so to avoid that we should declare variable as volatile.
	volatile is generally used when dealing with external events, like interrupts of hardware related pins.

	Example. reading adc values.

	const voltile means you can not modify or alter the value of that variable in code. only external event can change the value.
	controller pins are generally defines as volatile. may be by declaring variable as volatile controller will do "read by pin" 
	not "read by latch"... this is my assumtion. may be wrong...
	but still there is lots of confusion when to choose variable as volatile..
	
	A variable should be declared volatile whenever its value could change unexpectedly. In practice, only three types of variables could change:
	Memory-mapped peripheral registers or hardware registers.
	Global variables modified by an interrupt service routine
	Global variables within a multi-threaded application

volatile vs const volatile, Explain?
What does the keyword volatile mean? Give three different examples of its use.? 
	(a) Can a parameter be both const and volatile? Explain your answer.
	(b) Can a pointer be volatile? Explain your answer.
	(c) What is wrong with the following function?:
	int square(volatile int *ptr)
	{
		return *ptr * *ptr;
	}
ANS:
	A volatile variable is one that can change unexpectedly. Consequently, the compiler can make no assumptions about the value of the variable. 
	In particular,the optimizer must be careful to reload the variable every time it is used instead of holding a copy in a register. 
	Examples of volatile variables are:
	
	(a) Hardware registers in peripherals (e.g., status registers)
	(b) Non-stack variables referenced within an interrupt service routine.
	(c) Variables shared by multiple tasks in a multi-threaded application.

	The answers are as follows:
	(a) Yes. An example is a read only status register. It is volatile because it can change unexpectedly. It is const because 
		the program should not attempt to modify it.
	(b) Yes. Although this is not very common. An example is when an interrupt service routine modifies a pointer to a buffer.
	(c) This one is wicked. The intent of the code is to return the square of the value pointed to by *ptr. However, since *ptr points 
	to a volatile parameter, the compiler will generate code that looks something like this:
	int square(volatile int *ptr)
	{
		int a,b;
		a = *ptr;
		b = *ptr;
		return a * b;
	}
	Since it is possible for the value of *ptr to change unexpectedly, it is possible for a and b to be different. Consequently, 
	this code could return a number that is not a square! The correct way to code this is:
	long square(volatile int *ptr)
	{
		int a;
		a = *ptr;
		return a * a;
	}

	Another use for volatile is signal handlers. If you have code like this:
	quit = 0;
	while (!quit)
	{
		/* very small loop which is completely visible to the compiler */
	}
	The compiler is allowed to notice the loop body does not touch the quit variable and convert the loop to a while (true) loop. 
	Even if the quit variable is set on the signal handler for SIGINT and SIGTERM; the compiler has no way to know that.
	However, if the quit variable is declared volatile, the compiler is forced to load it every time, because it can be modified elsewhere. 
	This is exactly what you want in this situation.
	Courtesy: http://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c

What is difference between static and extern?

Can we declare static variable in header file?
	You can't declare a static variable without defining it as well (this is because the storage class modifiers static 
	and extern are mutuallyexclusive). 
	A static variable can be defined in a header file, but this would cause each source file that included the header file to have 
	its own private copy of the variable, which is probably not what was intended.

Can a static variable accessed from outside of the file?

Can we declare main() function as static?
	No. The C spec actually says somewhere in it  that the main function cannot be static.
	The reason for this is that static means "don't let anything outside this source file use this object". The benefit is that it protects 
	against name collisions in C 
	when you go to link (it would be bad bad bad if you had two globals both named "is_initialized" in different files... they'd get 
	silently merged, unless you made them static). It also allows the compiler to perform certain optimizations that it wouldn't 
	be able to otherwise. These two reasons are why static is a nice thing to have.

	Since you can't access static functions from outside the file, how would the OS be able to access the main function to start your program? 
	That's why main can't be static.
	Some compilers treat "main" specially and might silently ignore you when you declare it static.
	
Array pointer:

Array problem:

	Buffer Overruns and out of bound:
	Buffer overruns occur when memory outside of the allocated boundaries is overwritten. We call it data corruption. This is 
	nasty because it may not become visible at the place where the memory is overwritten. It may appear when we access that 
	memory address, which can happen much later part of code. When it happens, our program behaves strangely because the
	memory location has wrong value.

	
There is a char * pointer that points to some ints, and what should be done to step over it ?
How does declaring function parameters as 'const' help in better,safer code ?
Which of the following is correct . Why does point no 'i' gives output sometime & sometimes it does not give output ?
	i. char *a = malloc(strlen(str));
	strcpy(a, str);
	ii. char *a = malloc(strlen(str) + 1);
	strcpy(a, str);

Write a program to move all 0's to one side and 1's on ther side of array?
Write a program to find largest element in an array?
Write a program to find second largest element from array?

Can we increment the base address of array? Justify your answer.
	No, Because once we initialize the array variable, the pointer points base address only & it's fixed  and constant pointer.

What is the output of program.
	int a[5] = {1,2,3,4,5};
	int *ptr = (int*) (&a +1);
	int *ptr = (int*) (a+1); 

	you see, for your program above, a and &a will have the same numerical value,and I believe that's where your whole confusion lies.You may wonder that if they are the same,
	the following should give the next address after a in both cases,going by pointer arithmetic:

	(&a+1) and (a+1)

	But it's not so!!Base address of an array (a here) and Address of an array are not same! a and &a might be same numerically ,but they are not the same type. 
	a is of type int* while &a is of type int (*)[5],ie , &a is a pointer to (address of ) and array of size 5.But a as you know is the address of the first element of the array.Numerically 
	they are the same as you can see from the illustration using ^ below.

	But when you increment these two pointers/addresses, ie as (a+1) and (&a+1), the arithmetic is totally different.While in the first case it "jumps" to the address of the next element in the array, 
	in the latter case it jumps by 5 elements as that's what the size of an array of 5 elements.
 
What is output of the program?
	int main()
	{
				int arr[10];
				int *ptr = arr;
				ptr++;
				arr++;
				return 0;
	}

	The statement arr++ will give you lvalue error. Because hear you are trying to increment base address of array and by default base address of array is constant pointer(constant value) so,
	arr  =  arr+1;
	i.e according to rule on LHS of assignment operator there always should be lvalue i.e variable not constant.
	
How do I make an array of complex number in C?
http://c-faq.com/~scs/cgi-bin/faqcat.cgi?sec=ptrs

What will be output when you will execute following c code?
	#include
	void main(){
		int const SIZE=5;
		int expr;
		double value[SIZE]={2.0,4.0,6.0,8.0,10.0};
		expr=1|2|3|4;
		printf("%f",value[expr]);
	}
	Explanation:
	Size of any array in c cannot be constantan variable, size of array can be enum, macro.
	
How function poiner are shared between different process ?
	two processes can not share function pointers.
	if you want to use functions in two processes make library for that functions and use that library in your processes.
	
Searching for duplicates in array?
	Simple algorithm:
	int yes = 1, i, j;
	for (i = 0; i < n; ++i)
	{
	   for (j = i + 1; j < n; ++j) if (arr[i] == arr[j])
	   {
		   printf("Found a duplicate of %d\n", arr[i]);
		   yes = 0;
		   break;
	   }
	   if (!yes) break;
	}
	if (yes) printf("No duplicates");

	Efficient Algorithim:
	void rmdup(int *array, int length)
	{
		int *current , *end = array + length - 1;

		for ( current = array + 1; array < end; array++, current = array + 1 )
		{
			while ( current <= end )
			{
				if ( *current == *array )
				{
					*current = *end--;
				}
				else
				{
					current++;
				}
			}
		}
	}
 
differance b/w array and pointer and const strings ?
Can the sizeof operator be used to tell the size of an array passed to a function?

What is the difference between array_name and &array_name?
	One is a pointer to the first element in the array; the other is a pointer to the array as a whole.

Why can't constant values be used to define an array's initial size?
	char a[ 512 ];
	char a[ sizeof( struct cacheObject ) ];
	char buf[ sizeof( struct cacheObject ) * MAX ];
	Enumerations are allowed too.
	
	int max = 512; /* not a constant expression in C */
	char buffer[ max ]; /* not valid C */
	
Whats is Stack overflow attack??...then he gave me a scenario where there was a open source code at a server and you have your piece of code at that server.
You as a client are allowed to invoke a method which takes in a array as a parameter which is not checked for overflow validation. 
I had to induce a buffer overflow attack and make the method to pass control\85 

Pointer:
What does the keyword const mean? 
Const vs static vs #define?
	const char *ptr 		: ptr is a pointer to a char, where you can't change the value of the char (at least not through the pointer(without casting the constness away)).
	char * const ptr 		: ptr is a constant pointer to a char, where you can change the char, but you can't make the pointer point to a different char.
	const char *const ptr	: ptr is a constant pointer to a constant char, i.e. you can change neither where the pointer points nor the value of the pointee.
	
What is hashing?
memmove vs memcpy vs memset ?
write your own malloc()?
malloc vs calloc vs realloc?
what is free()? how does free know how much memory to de-allocate?

Why does malloc() return a void*?
	It's because malloc() has no idea which type of object we want to put in that memory. Initialization is our responsibility. 

Common Bugs for Memory Allocation?



    Null dereferencing:
    Trying to use -> or * operator on a NULL pointer.

    Double Freeing:
    Calling delete or free() on a block of memory twice.

    Accessing invalid memory:
    Trying to use -> or * operator on a pointer that has not been allocated yet or that has been freed already.

    Memory leaks:
    Not freeing a block of memory when we are finished with it.

NULL vs wild vs dangling vs generic pointer ? Why NULL pointer is required?
	
	NULL pointer:
	Literal meaning of NULL pointer is a pointer which is pointing to nothing. NULL pointer points the base address of segment.
	Note: We cannot copy any thing in the NULL pointer.
	
	Examples of NULL pointer:
	1. int *ptr=(char *)0;
	2. float *ptr=(float *)0;
	3. char *ptr=(char *)0;
	4. double *ptr=(double *)0;
	5. char *ptr=\92\0\92;
	6. int *ptr=NULL;

	What is meaning of NULL?
	NULL is macro constant which has been defined in the heard file stdio.h, alloc.h, mem.h, stddef.h and stdlib.h as
	#define NULL 0

	The null pointer is used in three ways:
	1) To stop indirection in a recursive data structure.
	2) As an error value.
	3) As a sentinel value.
		
	Wild Pointers:
	Wild pointers are created by omitting necessary initialization prior to first use. Thus, strictly speaking, every pointer in programming languages which do not enforce initialization begins as a wild pointer. 
	This most often occurs due to jumping over the initialization, not by omitting it. Most compilers are able to warn about this.
	A pointer in c which has not been initialized is also known as wild pointer.
	{
		int* a;
		/* a is wild pointer, it is not initialized and it may have some garbage value*/
	}

	correct way is
	{
		int* a = NULL;
	}

	Note: There is difference between the NULL pointer and wild pointer. Null pointer points the base address of segment while wild pointer doesn\92t point any specific memory location.
	
	Dangling Pointer : how it is different from memory leak?
	If a pointer is de-allocated or freed and the pointer is not assigned to NULL, then it may still contain that address and accessing the pointer means that we are trying to access that location and it will give an error. 
	This type of pointer is called dangling pointer.
	
	Solution of this problem: Make the variable as static variable.

	Examples of Dangling Pointers
	int main()
	{
		int *p;
		p = (int *) malloc (sizeof (int));
		free(p);
		*p=10;
	}
	In the above piece of code we are using *p after we free the memory to it. Such usage is called dangling pointer usage.
	
	int main()
	{
		int *p = NULL;
		{
			int a = 10;
			p = &a;
		}
		/*address of a is out of scope and pointer p is now called the dangling pointer, we should initialize the p to NULL before coming out or initialize the pointer to some known value before using it again*/
	\85
	}
	
	int* fun1()
	{
		int a = 10;
		return(&a); /*in this line we are returning the pointer of variable \91a\92 which is out scope.*/
	}
	
	Dangling pointers are are those that point to memory locations which have already been freed. For example:
	int *a = malloc(sizeof(int));
	free(a);
	// a is now a dangling pointer

	Memory leaks are quite the opposite of dangling pointers. Memory leaks happen when memory locations are not freed, but there is no way to refer to them (i.e., no pointers are pointing to them).
	int *a = malloc(sizeof(int));
	a = 0;
	// now a no longer points to the memory that we just allocated, causing a memory leak

	Unlike higher-level languages with garbage collectors, it is critical to always keep track of allocated memory when programming in C

	Generic pointer:
	void pointer in c is known as generic pointer. Literal meaning of generic pointer is a pointer which can point type of data.
	Example:
	void *ptr;
	Here ptr is generic pointer.

	1. We cannot dereference generic pointer. 
		A void pointer can be dereferenced only after explicit casting. e.g 
		int a = 5;
		void *b = &a;
		printf(\93%d\n\94, *((int*)b));

	2. We can find the size of generic pointer using sizeof operator.
	3. Generic pointer can hold any type of pointers like char pointer, struct pointer, array of pointer etc without any typecasting.
	4. Any type of pointer can hold generic pointer without any typecasting.
	5. Generic pointers are used when we want to return such pointer which is applicable to all types of pointers. 
	For example return type of malloc function is generic pointer because it can dynamically allocate the memory space to stores 
	integer, float, structure etc. hence we type cast its return type to appropriate pointer type.
	
	some tricks for pointers:
	*array = *(array +0) = array[0];
	arr[0] = &arr1;
	p[i] = *(p+i) : P[0][0][0]=*(p[0][0]+0)=**p[0]=***p
	p[i][j] == *(*(p+i)+j);
	*&i = i;
	-> = (*).
	Rule: * and & always cancel to each other
	Note: %s is used to print stream of characters up to null (\0) character.


Why should we assign NULL to the elements (pointer) after freeing them?
	This is paranoia based on long experience. After a pointer has been freed, you can no longer use the pointed-to data. The pointer is said to dangle; it doesn\92t point at anything useful.
	If you NULL out or zero out a pointer immediately after freeing it, your program can no longer get in trouble by using that pointer. True, you might go indirect on the null pointer instead, 
	but that\92s something your debugger might be able to help you with immediately.
	Also, there still might be copies of the pointer that refer to the memory that has been deallocated; that\92s the nature of C. Zeroing out pointers after freeing them won\92t solve all problems.

What is a null pointer assignment error? What are bus errors, memory faults, and core dumps?
	These are all serious errors, symptoms of a wild pointer or subscript. Null pointer assignment is a message you might get when an MS-DOS program finishes executing. 
	Some such programs can arrange for a small amount of memory to be available \93where the NULL pointer points to (so to speak). If the program tries to write to that area, it will overwrite the data put there by the compiler.
	When the program is done, code generated by the compiler examines that area. If that data has been changed, the compiler-generated code complains with null pointer assignment. 
	This message carries only enough information to get you worried. There\92s no way to tell, just from a null pointer assignment message, what part of your program is responsible for the error. 
	Some debuggers, and some compilers, can give you more help in finding the problem.
	Bus error: core dumped and Memory fault: core dumped are messages you might see from a program running under UNIX. They\92re more programmer friendly. Both mean that a pointer or an array subscript was wildly out of bounds.
	You can get these messages on a read or on a write. They aren\92t restricted to null pointer problems. The core dumped part of the message is telling you about a file, called core, 
	that has just been written in your current directory. This is a dump of everything on the stack and in the heap at the time the program was running. 
	With the help of a debugger, you can use the core dump to find where the bad pointer was used.  That might not tell you why the pointer was bad, but it\92s a step in the right direction. 
	If you don\92t have write permission in the current directory, you won\92t get a core file, or the core dumped message

What is static memory allocation and dynamic memory allocation?
	Static memory allocation: The compiler allocates the required memoryspace for a declared variable. By using the address of operator,thereserved address is obtained and this address may be assigned to apointer variable.
	Since most of the declared variable have staticmemory,this way of assigning pointer value to a pointer variable isknown as static memory allocation. 
	memory is assigned duringcompilation time.Dynamic memory allocation: It uses functions such as malloc( ) orcalloc( ) to get memory dynamically.
	If these functions are used to getmemory dynamically and the values returned by these functions areassingned to pointer variables, such assignments are known asdynamic memory allocation.
	memory is assined during run time.

What is memory leakage? How can we avoid it?
	Memory leak occurs when programmers create a memory in heap and forget to delete it.
	Memory leaks are particularly serious issues for programs like daemons and servers which by definition never terminate.
	/* Function with memory leak */
	#include 
	void f()
	{
	   int *ptr = (int *) malloc(sizeof(int));
	   /* Do some work */
	   return; /* Return without freeing ptr*/
	}
	To avoid memory leaks, memory allocated on heap should always be freed when no longer needed.
	/* Function without memory leak */
	#include ;
	void f()
	{
	   int *ptr = (int *) malloc(sizeof(int));
	   /* Do some work */
	   free(ptr);
	   return;
	}

malloc vs calloc vs realloc ?
Is realloc() uses the same memory location which was used by malloc()?
Difference between arrays and pointers?
Is using exit() the same as using return?
declaring a variable vs defining a variable

create a custom malloc and free function using linked lists ?
set an integer variable at the absolute address 0x67a9 to the value 0xaa55?
	int *ptr;
	ptr = (int *)0x67a9;
	*ptr = 0xaa55;

	A more obfuscated approach is:
	*(int * const)(0x67a9) = 0xaa55;

What is code optimization?
Typically, this new key word is __interrupt. The following code uses __interrupt to define an interrupt service routine. Comment on the code?
	__interrupt double compute_area(double radius) {
		double area = PI * radius * radius;
		printf(\93nArea = %f\94, area);
		return area;
	}

	This function has so much wrong with it, it\92s almost tough to know where to start.
	(a) Interrupt service routines cannot return a value. If you don\92t understand this, then you aren\92t hired.
	(b) ISR\92s cannot be passed parameters. See item (a) for your employment prospects if you missed this.
	(c) On many processors / compilers, floating point operations are not necessarily re-entrant. In some cases one needs to stack additional registers, in other cases,
		one simply cannot do floating point in an ISR. Furthermore, given that a general rule of thumb is that ISRs should be short and sweet, one wonders about the wisdom of doing floating point math here.
	(d) In a similar vein to point (c), printf() often has problems with reentrancy and performance.

What is a memory leak? What is a segmentation fault?*
what is stack  overflow and heap overflow?
what is a core dump?
	A core dump is the recorded state of the working memory of a computer program at a specific time, generally when the program has terminated abnormally includes the program counter and stack pointer, 
	memory management information, and other processor and operating system flags and information a fatal error usually triggers the core dump, often buffer overflows, 
	where a programmer allocates too little memory for incoming or computed data, or access to null pointers, a common coding error when an unassigned memory reference variable is accessed.
	
What is a stack frame, stack pointer & frame pointer ?
write a code  to check whether a stack  grows upwards or downwards?
Tell the role of brk() in malloc / Tell the relation between heap and brk?
Tell the relation between Malloc and MMAP

What does the following code fragment output and why?
	char *ptr;
	if ((ptr = (char *)malloc(0)) == NULL) {
		puts(\93Got a null pointer\94);
	}
	else {
		puts(\93Got a valid pointer\94);
	}
	
	Note: malloc(0) gives a valid pointer but allocate zero bytes.
	
What is the difference between declaring a variable and defining a variable?
	 Declaring a variable means describing its type to the compiler but notallocating any space for it. Defining a variable means declaring it andalso allocating space to hold the variable.
	 You can also initialize avariable at the time it is defined.

why n++ executes faster than n+1? 
	The expression n++ requires a single machine instruction such as INR to carry out the increment operation whereas, n+1 requires more instructions to carry out this operation.
		
When does the compiler not implicitly generate the address of the first element of an array?
	Whenever an array name appears in an expression such as
		array as an operand of the size of operator
		array as an operand of & operator
		array as a string literal initializer for a character array
	Then the compiler does not implicitly generate the address of the address of the first element of an array.

Why doesn't the following statement work?
	char str[ ] = "Hello" ;
	strcat ( str, '!' ) ;

	The string function strcat( ) concatenates strings and not a character. The basic difference between a string and a character is that a string is a collection of characters, 
	represented by an array of characters whereas a character is a single character. To make the above statement work writes the statement as shown below:
	strcat ( str, "!" ) ;

string:
What is string?
	The string in C programming language is actually a one-dimensional array of characters which is terminated by a null character '\0'. Thus a null-terminated string containn
	the characters that comprise the string followed by a null.

What is difference between these two,
	char ptr[] = "string";
	char *ptr = "string";
	
	The two declarations are not the same.
	First one is the array of character i.e. string and second one is the string literals.
	char ptr[] = "string"; declares a char array of size 7 and initializes it with the characters s ,t,r,i,n,g and \0. You are allowed to modify the contents of this array.
	char *ptr = "string"; declares ptr as a char pointer and initializes it with address of string literal "string" which is read-only. Modifying a string literal is an undefined behavior. 
	What you saw(seg fault) is one manifestation of the undefined behavior.

What is the difference between strings and character arrays?
	A major difference is: string will have static storage duration, whereasas a character array will not, unless it is explicity specified by using thestatic keyword.
	Actually, a string is a character array with following properties: 
	the multibyte character sequence, to which we generally call string,is used to initialize an array of static storage duration. 
		The size of thisarray is just sufficient to contain these characters plus the terminatingNUL character.
	it not specified what happens if this array, i.e., string, is modified.
	Two strings of same value[1] may share same memory area. Forexample, 
	
		in the following declarations:
		char *s1 = \93Calvin and Hobbes\94;
		char *s2 = \93Calvin and Hobbes\94;
		the strings pointed by s1 and s2 may reside in the same memorylocation. 
		But, it is not true for the following:
		char ca1[] = \93Calvin and Hobbes\94;
		char ca2[] = \93Calvin and Hobbes\94;
		The value of a string is the sequence of the values of the containedcharacters, in order.
		
Find a word from string?
write a program to find repeated character in a given string? code should be generic?
Implement string reverse program without using temporary buffer and strrev function?
Write a program to implement memcpy() on your own 
Difference between library call and a system call
Write a program to count total number of vowel,consonant present in given string?
Write a program to check weather  string is palindrome or not?
Can we increment the base address of array? Justify your answer.
What is difference between array and pointer?

string vs array?
	Merits:
	(a) We can easily access each element of array.
	(b) Not necessity to declare too many variables.
	(c) Array elements are stored in continuous memory location.
	Demerits:
	(a) Wastage of memory space. We cannot change size of array at the run time.
	(b) It can store only similar type of data
	
write a shortest string copy function?
while (*str++ = *dst++) 
{}

What is the difference between a string copy (strcpy) and a memory copy (memcpy)? When should each be used? when we should strncpy()?
	The strcpy() function is designed to work exclusively with strings. It copies each byte of the source string to the destination string and stops when the terminating null character (\0) has been moved. 
	On the other hand, the memcpy() function is designed to work with any type of data.
	Because not all data ends with a null character, you must provide the memcpy() function with the number of bytes you want to copy from the source to the destination.
	strncpy()= to copy a portion of a string.
	
What is the output of following program?
	int main()
	{
		  char str[] = "vishnu";
		  printf("%d %d\n",sizeof(str),strlen(str));
	}
	Here char str[] = " 'v'. 'i' ,'s','h','n',u','\0' ";
	so sizeof operator always count null character whereas strlen skip null character.

Write a program to implement strlen(), strcpy(), strncpy(), strrev(), strcmp() function"?
	1. strlen:
	int my_strlen(const char * str)
	{
		int count;
		while(* str != '\0') {
			count++;
			str++;
		}
		return 0;
	}

	2. strcpy:
	void my_strcpy(char * dest, const char* src)
	{
		while(* src != '\0') {
			*dest = *src;
			dest++;
			src++;
		}
		*dest = '\0';
	}

	3. strrev:
	void my_strrev(char *str,size)
	{
		int i;
		char temp;
		for(i=0;i<=size/2;i++) {
			temp = str[i];
			str[i] = str[size-i];
			str[size-i] = temp;
		}
	}
	int main()
	{
		char str[10] = "vishnu";
		int len;
		len = strlen(str);
		my_strrev(str,len-1);
		printf("strrev = %s\n",str);
		return 0;
	}

	4. strcmp :
	void my_strcmp(char * dest, const char* src)
	{
		 while(*str != '\0' && *dest != '\0') {
			str++;
			dest++;
		}
		return (*src - *dest);
	}
	int main()
	{
		char str[10];
		char dest[10];
		int i;
		i = my_strcmp(dest,src);
		if(i == 0 )
			printf("strings are equal\n");
		if(i < 0)
			printf(" string1 is less than string2\n");
		if(i > 0)
			printf("string2 is greter than string1\n");
		return 0;
	} 

	5. strncpy
	void my_strncpy(char * dest, const char* src,int n)
	{
		while(*src != '\0' && n != 0) {
			*dest = *src;
			dest++;
			src++;
			n--;
		}
		while(n) {
			*dest = '\0';
			n--;
		}
	}

Write a program to check weather  string is palindrome or not?
	int main()
	{
		char string[25], reverse_string[25] = {'\0'};
		int  i, length = 0, flag = 0;
		fflush(stdin);
		printf("Enter a string \n");
		gets(string);
		for (i = 0; string[i] != '\0'; i++) {
			length++;
		}
	   
		for (i = length - 1; i >= 0; i--) {
			reverse_string[length - i - 1] = string[i];
		}
		if(strcmp(string,reverse_string) == 0 )
			printf("%s is palindrome\n");
		else
			printf("%s is not palindrome\n");
		return 0;
	}

What is the difference between a string copy (strcpy) and a memory copy (memcpy)? When should each be used?
	The strcpy() function is designed to work exclusively with strings. It copies each byte of the source string to the destination string and stops when the terminating null character (\0) has been moved. 
	On the other hand, the memcpy() function is designed to work with any type of data.
	Because not all data ends with a null character, you must provide the memcpy() function with the number of bytes you want to copy from the source to the destination. 
	The following program shows examples of both thestrcpy() and the memcpy() functions:

	#include <stdio.h>
	#include <string.h>
	typedef struct cust_str {
		 int  id;
		 char last_name[20];
		 char first_name[15];
	} CUSTREC;
	void main(void);
	void main(void)
	{
		 char*   src_string = "This is the source string";
		 char    dest_string[50];
		 CUSTREC src_cust;
		 CUSTREC dest_cust;
		 printf("Hello!  I'm going to copy src_string into dest_string!\n");
		 /* Copy src_string into dest_string. Notice that the destination
			string is the first argument. Notice also that the strcpy()
			function returns a pointer to the destination string. */
		 printf("Done! dest_string is: %s\n",
				strcpy(dest_string, src_string));
		 printf("Encore! Let's copy one CUSTREC to another.\n");
		 printf("I'll copy src_cust into dest_cust.\n");
		 /* First, initialize the src_cust data members. */
		 src_cust.id = 1;
		 strcpy(src_cust.last_name, "Strahan");
		 strcpy(src_cust.first_name, "Troy");
		 /* Now, use the memcpy() function to copy the src_cust structure to
			the dest_cust structure. Notice that, just as with strcpy(), the
			destination comes first. */
		 memcpy(&dest_cust, &src_cust, sizeof(CUSTREC));
		 printf("Done! I just copied customer number #%d (%s %s).",
				   dest_cust.id, dest_cust.first_name, dest_cust.last_name);
	}

	When dealing with strings, you generally should use the strcpy() function, because it is easier to use with strings. 
	When dealing with abstract data other than strings (such as structures), you should use the memcpy()function.
	
How can I remove the trailing spaces from a string?
	The C language does not provide a standard function that removes trailing spaces from a string. It is easy, however, to build your own function to do just this. 
	The following program uses a custom function namedrtrim() to remove the trailing spaces from a string. It carries out this action by iterating through the string backward, 
	starting at the character before the terminating null character (\0) and ending when it finds the first nonspace character. When the program finds a nonspace character, 
	it sets the next character in the string to the terminating null character (\0), thereby effectively eliminating all the trailing blanks. Here is how this task is performed:

	#include <stdio.h>
	#include <string.h>
	void main(void);
	char* rtrim(char*);
	void main(void)
	{
		 char* trail_str = "This string has trailing spaces in it.               ";
		 /* Show the status of the string before calling the rtrim()
			function. */
		 printf("Before calling rtrim(), trail_str is '%s'\n", trail_str);
		 printf("and has a length of %d.\n", strlen(trail_str));
		 /* Call the rtrim() function to remove the trailing blanks. */
		 rtrim(trail_str);
		 /* Show the status of the string
			after calling the rtrim() function. */
		 printf("After calling rtrim(), trail_str is '%s'\n", trail_str);
		 printf("and has a length of %d.\n", strlen(trail_str));
	}
	/* The rtrim() function removes trailing spaces from a string. */
	char* rtrim(char* str)
	{
	int n = strlen(str) - 1;     /* Start at the character BEFORE
										 the null character (\0). */
		 while (n>0)            /* Make sure we don't go out of bounds... */
		 {
			  if (*(str+n) != ' ')    /*  If we find a nonspace character: */
			  {
				   *(str+n+1) = '\0'; /* Put the null character at one
										 character past our current
										 position. */
				   break;             /* Break out of the loop. */
			  }
			  else      /* Otherwise, keep moving backward in the string. */
				   n--;
		 }
		 return str;                  /* Return a pointer to the string. */
	}

	Notice that the rtrim() function works because in C, strings are terminated by the null character. With the insertion of a null character after the last nonspace character, 
		the string is considered terminated at that point, and all characters beyond the null character are ignored.

How can I remove the leading spaces from a string?
	The C language does not provide a standard function that removes leading spaces from a string. It is easy, however, to build your own function to do just this. 
	you can easily construct a custom function that uses thertrim() function in conjunction with the standard C library function strrev() to remove the leading spaces from a string. Look at how this task is performed:

	#include <stdio.h>
	#include <string.h>
	void main(void);
	char* ltrim(char*);
	char* rtrim(char*);
	void main(void)
	{
		 char* lead_str = "          This string has leading spaces in it.";
		 /* Show the status of the string before calling the ltrim()
			function. */
		 printf("Before calling ltrim(), lead_str is '%s'\n", lead_str);
		 printf("and has a length of %d.\n", strlen(lead_str));
		 /* Call the ltrim() function to remove the leading blanks. */
		 ltrim(lead_str);
		 /* Show the status of the string
			after calling the ltrim() function. */
		 printf("After calling ltrim(), lead_str is '%s'\n", lead_str);
		 printf("and has a length of %d.\n", strlen(lead_str));
	}
	/* The ltrim() function removes leading spaces from a string. */
	char* ltrim(char* str)
	{
		 strrev(str);    /* Call strrev() to reverse the string. */
		 rtrim(str);     /* Call rtrim() to remove the "trailing" spaces. */
		 strrev(str);    /* Restore the string's original order. */
		 return str;     /* Return a pointer to the string. */
	}
	/* The rtrim() function removes trailing spaces from a string. */
	char* rtrim(char* str)
	{
		 int n = strlen(str) - 1;     /* Start at the character BEFORE
										 the null character (\0). */
		 while (n>0)            /* Make sure we don't go out of bounds... */
		 {
			  if (*(str+n) != ' ')    /* If we find a nonspace character: */
			  {
				   *(str+n+1) = '\0'; /* Put the null character at one
										 character past our current
										 position. */
				   break;             /* Break out of the loop. */
			  }
			  else      /* Otherwise, keep moving backward in the string. */
				   n--;
		 }
		 return str;                  /* Return a pointer to the string. */
	}

	Notice that the ltrim() function performs the following tasks: First, it calls the standard C library functionstrrev(), which reverses the string that is passed to it. 
	This action puts the original string in reverse order, thereby creating "trailing spaces" rather than leading spaces. Now, the rtrim() function is used to remove the "trailing spaces" from the string. 
	After this task is done, the strrev() function is called again to "reverse" the string, thereby putting it back in its original order.

How can I copy just a portion of a string?
	You can use the standard C library function strncpy() to copy one portion of a string into another string. Thestrncpy() function takes three arguments: the first argument is the destination string, 
	the second argument is the source string, and the third argument is an integer representing the number of characters you want to copy from the source string to the destination string. 
	For example, consider the following program, which uses thestrncpy() function to copy portions of one string to another:

	#include <stdio.h>
	#include <string.h>
	void main(void);
	void main(void)
	{
		 char* source_str = "THIS IS THE SOURCE STRING";
		 char dest_str1[40] = {0}, dest_str2[40] = {0};
		 /* Use strncpy() to copy only the first 11 characters. */
		 strncpy(dest_str1, source_str, 11);
		 printf("How about that! dest_str1 is now: '%s'!!!\n", dest_str1);
		 /* Now, use strncpy() to copy only the last 13 characters. */
		 strncpy(dest_str2, source_str + (strlen(source_str) - 13), 13);
		 printf("Whoa! dest_str2 is now: '%s'!!!\n", dest_str2);
	}

	The first call to strncpy() in this example program copies the first 11 characters of the source string intodest_str1. This example is fairly straightforward, one you might use often. 
	The second call is a bit more complicated and deserves some explanation. In the second argument to the strncpy() function call, the total length of the source_str string 
	is calculated (using the strlen() function). Then, 13 (the number of characters you want to print) is subtracted from the total length of source_str. This gives the number of 
	remaining characters in source_str. This number is then added to the address of source_str to give a pointer to an address in the source string that is 13 characters from the end of source_str.

	Then, for the last argument, the number 13 is specified to denote that 13 characters are to be copied out of the string. The combination of these three arguments in the second call 
	to strncpy() sets dest_str2 equal to the last 13 characters of source_str.
	The example program prints the following output:

	How about that! dest_str1 is now: 'THIS IS THE'!!!
	Whoa! dest_str2 is now: 'SOURCE STRING'!!!

	Notice that before source_str was copied to dest_str1 and dest_st2, dest_str1 and dest_str2 had to be initialized to null characters (\0). 
	This is because the strncpy() function does not automatically append a null character to the string you are copying to. Therefore, you must ensure that you have put the 
	null character after the string you have copied, or else you might wind up with garbage being printed.


How can I convert a number to a string?
	Notice that the itoa() function takes three arguments: the first argument is the number you want to convert to the string, the second is the destination string to put the converted number into,
	and the third is the base, or radix, to be used when converting the number. The preceding example uses the common base 10 to convert the number to the string.
	The following functions can be used to convert integers to strings:
	Function Name		Purpose
	itoa()	-	Converts an integer value to a string.
	ltoa()	-	Converts a long integer value to a string.
	ultoa()	-	Converts an unsigned long integer value to a string.
	Note that the itoa(), ltoa(), and ultoa() functions are not ANSI compatible. An alternative way to convert an integer to a string (that is ANSI compatible) is to use the sprintf() function.

How can I convert a string to a number?
	To use the atoi() function, you simply pass it the string containing the number you want to convert. The return value from the atoi() function is the converted integer value.
	The following functions can be used to convert strings to numbers:
	Function Name		Purpose
	atof()	-	Converts a string to a double-precision floating-point value.
	atoi()	-	Converts a string to an integer.
	atol()	-	Converts a string to a long integer.
	strtod()	-	Converts a string to a double-precision floating-point value and reports any "leftover" numbers that could not be converted.
	strtol()	-	Converts a string to a long integer and reports any "leftover" numbers that could not be converted.
	strtoul()	-	Converts a string to an unsigned long integer and reports any "leftover" numbers that could not be converted.
	Sometimes, you might want to trap overflow errors that can occur when converting a string to a number that results in an overflow condition. 
	The following program shows an example of the strtoul() function, which traps this overflow condition:

How do you print only part of a string?
	The following program shows how to print only part of a string using the printf() function:

	#include <stdio.h>
	#include <string.h>
	void main(void);
	void main(void)
	{
		 char* source_str = "THIS IS THE SOURCE STRING";
		 /* Use printf() to print the first 11 characters of source_str. */
		 printf("First 11 characters: '%11.11s'\n", source_str);
		 /* Use printf() to print only the
			last 13 characters of source_str. */
		 printf("Last 13 characters: '%13.13s'\n",
					 source_str + (strlen(source_str) - 13));
	}

	
structure union bitfield:
What is difference between Structure and Unions?
	(i)    In structure every member has its own memory whereas in union its members share the same member space.
	(ii)  In structure, it is possible to initialize all the members at the same time which is not possible in case of union.
	(iii) A structure requires more space than union(for the same type of members).
	(iv) In union different interpretations of the same memory space are possible which is not so in case of structures.
	
	advantages of using Unions?
	(i) Efficient use of memory as it it does not demand memory space for its all members rather it require memory space for its largest member only.
	(ii) Same memory space can be interpreted differently for different members of the union
when should unions be used? Why do we need them in Embedded Systems  programming?
	Unions are particularly useful in Embedded programming or in situations where direct access to the hardware/memory is needed.
	Here is a trivial example:

	typedef union
	{
		struct {
			unsigned char byte1;
			unsigned char byte2;
			unsigned char byte3;
			unsigned char byte4;
		} bytes;
		unsigned int dword;
	} HW_Register;
	HW_Register reg;

	Then you can access the reg as follows:
	reg.dword = 0x12345678;
	reg.bytes.byte3 = 4;

	Endianism and processor architecture are of course important.
	Another useful feature is the bit modifier:
	typedef union
	{
		struct {
			unsigned char b1:1;
			unsigned char b2:1;
			unsigned char b3:1;
			unsigned char b4:1;
			unsigned char reserved:4;
		} bits;
		unsigned char byte;
	} HW_RegisterB;
	HW_RegisterB reg;

	With this code you can access directly a single bit in the register/memory address:
	x = reg.bits.b2;
	Low level system programming is a reasonable example.
	unions are used to breakdown hardware registers into the component bits. So, you can access an 8-bit register into the component bits.
	This structure would allow a control register to be accessed as a control_byte or via the individual bits. It would be important to ensure the bits map on to the correct register bits for a given endianness.
	typedef union {
		unsigned char control_byte;
		struct {
			unsigned int nibble  : 4;
			unsigned int nmi     : 1;
			unsigned int enabled : 1;
			unsigned int fired   : 1;
			unsigned int control : 1;
		}
	} ControlRegister;

Data Alignment & Structure Padding?
	Data Alignment: Data alignment means putting the data at a memory offset equal to some multiple of the word size, which increases the system\92s performance due to the way the CPU handles memory
	Data Structure Padding: To align the data, it may be necessary to insert some meaningless bytes between the end of the last data structure and the start of the next, which is data structure padding
	Here is a structure with members of various types, totaling 8 bytes before compilation:
	struct MixedData
	{
		char Data1;
		short Data2;
		int Data3;
		char Data4;
	};
	After compilation the data structure will be supplemented with padding bytes to ensure a proper alignment for each of its members:

	struct MixedData  /* After compilation in 32-bit x86 machine */
	{
		char Data1; /* 1 byte */
		char Padding1[1]; /* 1 byte for the following 'short' to be aligned on a 2 byte boundary assuming that the address where structure begins is an even number */
		short Data2; /* 2 bytes */
		int Data3;  /* 4 bytes - largest structure member */
		char Data4; /* 1 byte */
		char Padding2[3]; /* 3 bytes to make total size of the structure 12 bytes */
	};

	The compiled size of the structure is now 12 bytes. It is important to note that the last member is padded with the number of bytes required 
	so that the total size of the structure should be a multiple of the largest alignment of any structure member (alignment(int) in this case, which = 4 on linux-32bit/gcc)
	In this case 3 bytes are added to the last member to pad the structure to the size of a 12 bytes (alignment(int) \D7 3).

	struct FinalPad {
		float x;
		char n[1];
	};

	In this example the total size of the structure sizeof(FinalPad) = 8, not 5 (so that the size is a multiple of 4 (alignment of float)).
	struct FinalPadShort {	
		short s;
		char n[3];                                                                                
	};

	In this example the total size of the structure sizeof(FinalPadShort) = 6, not 5 (not 8 either) (so that the size is a multiple of 2 (alignment(short) = 2 on linux-32bit/gcc)).
	It is possible to change the alignment of structures to reduce the memory they require (or to conform to an existing format) by reordering structure members or changing the compiler\92s alignment (or \93packing\94) of structure members.
	struct MixedData  /* after reordering */
	{
		char Data1;
		char Data4;   /* reordered */
		short Data2;
		int Data3;  
	};

	The compiled size of the structure now matches the pre-compiled size of 8 bytes. Note that Padding1[1] has been replaced (and thus eliminated) by Data4 and Padding2[3] is no longer necessary as the structure is already aligned to the size of a long word.
	The alternative method of enforcing the MixedData structure to be aligned to a one byte boundary will cause the pre-processor to discard the pre-determined alignment of the structure members and thus no padding bytes would be inserted.
	While there is no standard way of defining the alignment of structure members, some compilers use #pragma directives to specify packing inside source files. Here is an example:

	#pragma pack(push)  /* push current alignment to stack */
	#pragma pack(1)     /* set alignment to 1 byte boundary */

	struct MyPackedData
	{
		char Data1;
		long Data2;
		char Data3;
	};

	#pragma pack(pop)   /* restore original alignment from stack */
	This structure would have a compiled size of 6 bytes on a 32-bit system. The above directives are available in compilers from Microsoft, Borland, GNU and many others.

	Another example:
	struct MyPackedData
	{
		char Data1;
		long Data2 __attribute__((packed));
		char Data3;
	};

	Courtesy: http://en.wikipedia.org/wiki/Data_structure_alignment
	http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/
	http://stackoverflow.com/questions/381244/purpose-of-memory-alignment
	http://stackoverflow.com/questions/6968468/padding-in-structures-in-c

describe the steps to add a new sysctl() or fnctl() ?
	sysctl is used to modify kernel parameters at runtime. The parameters are listed under /proc/sys/.
	Procfs is required for sysctl support in Linux. You can use sysctl to both read and write sysctl data.
	You must login as the root user to use any one of the following command.
	Method # 1: Setting value via procfs
		You can use standard echo command to write data to variables:
		# echo "value" > /proc/sys/location/variable
	Method # 2: Temporary on the command line
		Use sysctl command with -w option when you want to change a sysctl setting:
		sysctl -w variable=value
	Method # 3: Configuration file /etc/sysctl.conf
		This is recommended way. First open /etc/sysctl.conf file
		# vi /etc/sysctl.conf
	Now add value:
	variable = value
	Close and save the changes. Type the following command to load sysctl settings from the file /etc/sysctl.conf file:
	# sysctl -p
