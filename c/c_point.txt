compilation steps:
	there are 4 compilation steps they are 1.preprocessor 2.compiler 3.assembler 4.linker.
	1.preprocessor:-read the source code and resolve all preprocessor directives.
		gcc -E first.c -o first.i
	2.compiler:-transulates preprocessor code into assembly language.
		gcc -S -v first.i -o first.s
	3.assembler:-converts the assembler language in to binary language(or ) machine instructions.
		gcc -C -v first.s -o first.o
		objdump -D first.o
	4.linker:-applies the build process i.e., the linker links all the relocatable binary files and libraries.
		gcc first.o -o first
		objdump -D first

memory layout of a process:
	1. Text Segment:
		A text segment , also known as a code segment or simply as text, is one of the sections of a program in an object file or in memory,
		which contains executable instructions. Usually, the text segment is sharable so that only a single copy needs to be in 
		memory for frequently executed programs,such as text editors, the C compiler, the shells, and so on. Also, 
		the text segment is often read-only, to prevent a program from accidentally modifying its instructions.

	2. Initialized Data Segment:
		which contains the global variables and static variables that are initialized by the programmer.
		Note that, data segment is not read-only, since the values of the variables can be altered at run time.
		This segment can be further classified into initialized read-only area and initialized read-write area.
		
		For instance the global string defined by char s[] = "hello world" in C and a C statement like int debug=1 outside 
		the main (i.e. global) would be stored in initialized read-write area. 
		And a global C statement like const char* string = "hello world" makes the string literal "hello world" to be stored in 
		initialized read-only area and the character pointer variable string in initialized read-write area.
		Ex: static int i = 10 will be stored in data segment and global int i = 10 will also be stored in data segment

	3. Uninitialized Data Segment:
		Uninitialized data segment, often called the .bss segment, named after an ancient assembler operator that stood for block started 
		by symbol. Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executingcuninitialized 
		data starts at the end of the data segment and contains all global variables and static variables that are initialized to zero 
		or do not have explicit initialization in source code.
		
		For instance a variable declared static int i; would be contained in the BSS segment.
		For instance a global variable declared int j; would be contained in the BSS segment.

	4. Stack:
		The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory. On the standard 

	5. Heap:
		Heap is the segment where dynamic memory allocation usually takes place.
		The heap area begins at the end of the BSS segment and grows to larger addresses from there.The Heap area is managed 
		by malloc,realloc, and free, which may use the brk and sbrk system calls to adjust its size.
		they may also be implemented using mmap to reserve potentially non-contiguous regions of virtual memory into the 
		process virtual address space). The Heap area is shared by all shared libraries and dynamically loaded modules in a process.

C_Basic:

Data type :
	. Primary (primitive, fundamental) data types : char, int, flot, double, void.
	. Drived data types : array,function, pointer.
	. user defined : enum, struct, union.

	Note : default data type is signed int.
	Note : size of primitive data type in c depends upon the word length of the microprocessor. 
		In general we can say size of int is word length of microprocessor.
	Note : Why range of signed char is -128 to 127 not -127 to 128?
	Note : How to remember size of data type in c? ans : <limits.h>

variable is container of data.
Variable Attributes :
	. Name [identifier]
	. Value
	. Address

	Name:
		Note: In c any name is called identifier. 
		This name can be variable name, function name, enum constant name, micro constant name, goto label name, 
		any other data type name like structure, union, enum names or typedef name.

	Value : 
		Data which any variable keeps is known as value of variable.
		Note : Name of variable always returns value of the variable.

		Lvalue = Rvalue
		LValue must be any variable in c it cannot be a constant, function or any other data type of c.

		Note :
		LValue cannot be a integer constant, macro contant, const variable, data type and enum const. 

	Address:
		Location in a memory where a variable stores its data or value is known as address of variable. 
		To know address of any variable c has provided a special unary operator & which is known as deference operator or address operator. 
		This operator is only used with variables not with the constant.

		Note:
		We cannot write: &&a, because:
		&&a=& (&a) =& (address of variable a) =& (a constant number)
		And we cannot use address operator with constant.

		Note : it is not possible to have two variable with same name with same visibility. 
		But it is possible that two variable with same name but different visibility.
		In this case variable name can access only that variable which is more local. 
		In c there is not any way to access global variable if any local variable is present of same name.

		Important points about address of variables in c:
		1. Address of any variable in c is an unsigned integer. 
		It cannot be a negative number. So in printf statement we should use %u instead of %d, to print the address of any variable.
		%d: It is used to print signed decimal number.
		%u: It is used to print unsigned decimal number.

		Since, if the address of any variable will beyond the range of signed short int it will print a cyclic value.

		2. A programmer cannot know at which address a variable will store the data. It is decided by compiler or operating system.
		3. Any two variables in c cannot have same physical address.
		4. Address of any variable in c is not integer type so to assign an address to a integral variable we have to type cast the address.

	Address arithmetic in c:
	1. We can subtract address of any two variables but cannot add, multiply, divide two addresses.
	2. we can add or subtract a integer number with address.
	3. Other operators which can be used with addresses are:
		(a) Negation operator: !
		(b) Size operator: sizeof
		(c) Type casting operator: (Type)
		(e) Deference operator: *
		(f) Logical operator: &&, ||

Modifiers : which modify the meaning the basic data type in c.

   group		modifier
1. Size modifier	short, long
2. Signed modifier	signed, unsigned
3. Constant modifier	const , not const
4. Volatile modifier	volatole, non volatile
5. Storage class	auto, register, static, extern


Note :

1. Default modifier of storage class is auto when we declared the variable inside any function and default modifier of storage class 
	is static when we declared variable outside of all functions. 

In other word we can say if variable has declared locally then default storage class is auto and if it has declared globally 
	then default storage class of variable is extern.


2. Default storage class of function is extern.
	Rules for using modifier in c:
	1. We cannot use two modifiers of same groups in any particular data type of c.
	2. We can write modifier either before the data type or after the data type.
	3. Order of modifier including data type doesn\92t affect the meaning of declaration.
	4. There is one exception in rule 3. POINTER, FUNCTION and INTERRUPT modifier must be written after the data type.

3. const modifier :
	1. You can assign the value to the constant variables only at the time of declaration.
	2. Uninitialized constant variable is not cause of any compilation error. But you cannot assign any value after the declaration.

		Note : If you have declared the uninitialized variable globally then default initial value will be zero in case of integral data type 
		and null in case of non-integral data type. 

		If you have declared the uninitialized const variable locally then default initial value will be garbage.

	3. Constant variables executes faster than not constant variables.
	4. You can modify constant variable with the help of pointers.

	https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const

	const char *ptr :
		ptr is a pointer to a char, where you can't change the value of the char (at least not through the pointer 
			(without casting the constness away)).
	char * const ptr :
		ptr is a constant pointer to a char, where you can change the char, but you can't make the pointer point to a different char.
	const char *const ptr:
		ptr is a constant pointer to a constant char, i.e. you can change neither where the pointer points nor the value of the pointee.

	Now the first const can be on either side of the type so:
	const int * == int const *
	const int * const == int const * const

	If you want to go really crazy you can do things like this:

	int ** - pointer to pointer to int
	int ** const - a const pointer to a pointer to an int
	int * const * - a pointer to a const pointer to an int
	int const ** - a pointer to a pointer to a const int
	int * const * const - a const pointer to a const pointer to an int



4. volatile :
	1. A volatile variable can be changed by the background routine of preprocessor. 
		This background routine may be interrupt signals by microprocessor, threads, real times clocks etc.
	2. In simple word we can say a value volatile variable which has stored in the memory can be by any external sources.
	3. Whenever compiler encounter any reference of volatile variable is always load the value of variable from memory 
		so that if any external source has modified the value in the memory complier will get its updated value.
	4. Working principle of volatile variable is opposite to the register variable in c. 
		Hence volatile variables take more execution time than non-volatile variables.

	Question: What is meaning of following declaration in c?
		const volatile float f;
		register volatile char c;

5. storage class :

Some important terms:
Declaration: of a variable/function simply declares that the variable/function exists somewhere in the program 
        but the memory is not allocated for them.

Defination: when we define a variable/function, apart from the role of declaration, it also allocates memory for that variable/function. 

Assignment: Assigning any value to the variable at the time of declaration is known as initialization while assigning any value 
        to variable not at the time of declaration is known assignment.

Program: it may be simple file or group of multiple files.

Storage class: is modifier or qualifier of data types which decides:
        1.  In which area of memory a particular variable will be stored?  
        2. What is scope of variable?
        3. What is visibility of variable?

Visibility: Visibility means accessibility. Up to witch part or area of a program, we can access a variable, 
        that area or part is known as visibility of that variable. 

Scope: Meaning of scope is to check either variable is alive or dead. Alive means data of a variable has not destroyed from memory. 
        Up to which part or area of the program a variable is alive, that area or part is known as scope of a variable.

Note: If any variable is not visible it may have scope i.e. it is alive or may not have scope. 
        But if any variable has not scope i.e. it is dead then variable must not to be visible.

Referencing: & reference operator. Referencing means taking the address of an existing variable (using &) to set a pointer variable.
Dereferencing: * dereference operator. Dereferencing a pointer means using the * operator to access the value stored at a pointer.

storage class Types:
storage class		declared	scope 		visibility

1. auto			local		block		block
2. register		local		block		block
3. static
			globel		program		file
			local		program		block
4. extern
			globel		program		program
			local		program		block

auto :
	Automatic variables or auto variables are default storage class of local variable. An auto variable cannot be declared globally. (Why?)
	Properties :
	1. Default initial value of auto variable is garbage.
	2. Visibility of auto variable is within the block where it has declared.
	3. Scope of auto variable is within the block where it has declared.
	4. auto variable initialize each time.
	5. An auto variable gets memory at run time.

register :
	All register variable in c stores in CPU not in the memory.

	properties :
	1. register int a; We are only requesting not forcing to compiler to store variable a in CPU.
	2. A register variable execute faster than other variables because it is stored in CPU 
		so during the execution compiler has no extra burden to bring the variable from memory to CPU.
	3. Since a CPU have limited number of register so it is programmer responsibility which variable should declared 
		as register variable i.e. variable which are using many times should declared as a register variable.
	4. We cannot dereference register variable since it has not any memory address.
	5. Default initial value of register variable is garbage.
	6. Scope and visibility of register variable is block.

static :
	properties :
	1. It is not default storage class of global variables.
	2. Default initial value of static integral type variables are zero otherwise null.
	3. A same static variable can be declared many times but we can initialize at only one time.
	4. We cannot write any assignment statement globally.

	Note: Assigning any value to the variable at the time of declaration is known as initialization 
		while assigning any value to variable not at the time of declaration is known assignment.
	5. A static variable initializes only one time in whole program.
	6. If we declared static variable locally then its visibility will within a block where it has declared.
	7. If declared a static variable or function globally then its visibility will only the file 
		in which it has declared not in the other files.

extern :
	properties:
	1. It is default storage class of all global variables as well all functions.
	2. When we use extern modifier with any variables it is only declaration i.e. memory is not allocated for these variable.
	3. If you will not use extern keyword with global variables then compiler will automatically 
		initialize with default value to extern variable.
	4. Default initial value of extern integral type variable is zero otherwise null.
	5. We cannot initialize extern variable locally i.e. within any block either at the time of declaration or separately. 
		We can only initialize extern variable globally.
	6. If we declare any variable as extern variable then it searches that variable either it has been initialized or not. 
		If it has been initialized which may be either extern or static* then it is ok otherwise compiler will show an error.
	7. A particular extern variable can be declared many times but we can initialize at only one time.
	8. We cannot write any assignment statement globally.
	9. If declared an extern variables or function globally then its visibility will whole the program 
		which may contain one file or many files.

	Question:
	volatile vs const volatile, Explain?
	What does the keyword volatile mean? Give three different examples of its use.? 
		(a) Can a parameter be both const and volatile? Explain your answer.
		(b) Can a pointer be volatile? Explain your answer.
		(c) What is wrong with the following function?:
		int square(volatile int *ptr)
		{
			return *ptr * *ptr;
		}
	ANS:
	A volatile variable is one that can change unexpectedly. Consequently, the compiler can make no assumptions about the value of the variable. 
	In particular,the optimizer must be careful to reload the variable every time it is used instead of holding a copy in a register. 
	Examples of volatile variables are:
	
	(a) Hardware registers in peripherals (e.g., status registers)
	(b) Non-stack variables referenced within an interrupt service routine.
	(c) Variables shared by multiple tasks in a multi-threaded application.

	The answers are as follows:
	(a) Yes. An example is a read only status register. It is volatile because it can change unexpectedly. It is const because 
		the program should not attempt to modify it.
	(b) Yes. Although this is not very common. An example is when an interrupt service routine modifies a pointer to a buffer.
	(c) This one is wicked. The intent of the code is to return the square of the value pointed to by *ptr. However, since *ptr points 
	to a volatile parameter, the compiler will generate code that looks something like this:
	int square(volatile int *ptr)
	{
		int a,b;
		a = *ptr;
		b = *ptr;
		return a * b;
	}
	Since it is possible for the value of *ptr to change unexpectedly, it is possible for a and b to be different. Consequently, 
	this code could return a number that is not a square! The correct way to code this is:
	long square(volatile int *ptr)
	{
		int a;
		a = *ptr;
		return a * a;
	}

	Another use for volatile is signal handlers. If you have code like this:
	quit = 0;
	while (!quit)
	{
		/* very small loop which is completely visible to the compiler */
	}
	The compiler is allowed to notice the loop body does not touch the quit variable and convert the loop to a while (true) loop. 
	Even if the quit variable is set on the signal handler for SIGINT and SIGTERM; the compiler has no way to know that.
	However, if the quit variable is declared volatile, the compiler is forced to load it every time, because it can be modified elsewhere. 
	This is exactly what you want in this situation.
	Courtesy: http://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c


switch case :
switch(expression) {
	case constant-expression  :
		statement(s);
      		break; /* optional */
   	case constant-expression  :
   	   	statement(s);
   	   	break; /* optional */
   	/* you can have any number of case statements */
   	default : /* Optional */
   		statement(s);
}

properties :
	1. If we will not use break keyword in each case the program control will come in each case after the case
		witch satisfy the switch condition.
	2. We can write case statement in any order including the default case. That default case may be first case, 
		last case or in between the any case in the switch case statement.
	3. Case expression cannot be constant variable, string const.
	4. Case expression can be enum constant, character constant, macro constant.
	5. Case expression must be integral constant expression. If it is not integer then it is automatically type casted into integer value.
	6. duplicate case is not possible.
	7. switch expression must return an integer value. It cannot be float, double or long double
	8. switch case statement program control always move from the case which satisfy the switch condition 
		and end with either break keyword, terminating} or any null character which will come first.
	9. it is possible a switch case statement without any case but it is meaning less.
	10. We cannot use continue keyword in switch case. It is part loop.
	11. Nesting of switch case is possible in c.
	12. It is possible to write label of goto statement in the case of switch case statement.
	13. We can not declare any variable in any case of switch case statement.
	14.  switch case will not affect the value of variable a.
		Also sizeof operator doesn't affect the value of the any variable
	15. The expression used in a switch statement must have an integral or enumerated type, or be of a class type 
		in which the class has a single conversion function to an integral or enumerated type.

Loop :
	Looping is the process of repeating of same code until a specific condition doesn\92t satisfy.
	types :
		1. while
		2. do while
		3. for

	for (Expression 1; Expression 2; Expression 3) {
		Loop body
	}

	Expression 1:
		It is called initialization expression. Task of this expression is to initialize the looping variables.

	Properties of expression 1:
	1. Expression1 can initialize the more than one variable.
	2. Expression1 is optional.
	3. we cannot declare the variable at the expression1.

	Expression 2: 
		It is called as conditional expression. Task of expression is to check the condition and if it is false then it terminates the loop.

	Properties of expression2:
	1.  Expression2 can have more than one checking condition and if any condition is false loop will terminate.
	2. it is also optional.
	3. It can perform task of expression1 as well as expression3. That is it can initialize the variables as well as increment the variables.
	4. If expression2 is zero means condition is false and any non zero number means condition is true.

	Expression 3:
		It is called as instrumentation expression. Task of this expression is to increment the variable. 

	Properties:
	1. We can increment more than one variable at the same time in the expression3.
	2. it is also optional.

	Loop body:
		Loop body contains the part of code which we have to execute multiple numbers of times.

	Properties of loop body:
	1. If loop body contain only one statement then brace is optional.
	2. Loop without body is possible.
	3. Braces of loop body behave as block.

While loop:
	while (Expression) {
		Loop body;
	}

	Properties of while loop:
	1. Task of the expression is to check the condition. Loop will execute until condition is true otherwise loop will terminate.  
	2. If any expression returns zero then condition will false and if it returns any non- zero number then condition will true.
	3. In while loop condition expression is compulsory.
	4. While loop without any body is possible.
	5. In while loop there can be more than one conditional expression.
	6. If loop body contain only one statement the brace is optional.

do while :
	It is also called as post tested loop. It is used when it is necessary to execute the loop at least one time. Syntax:

	do {
		Loop body;
	} while (Expression);

break keyword in c:
	It is keyword of c programming. Task of this keyword is to bring the control from out of the loop in the case of looping.
	Another task of break keyword is to switch the control from one case to another case in case of switch case control statement.

continue:
	It is keyword of c and task of this keyword is to transfer the control of program at the beginning of loop.

goto statement :
	Transfers control to the labeled statement.

Array :
	An array is derived data type in c programming language which can store similar type of data in continuous memory location. 
	Data may be primitive type (int, char, float, double\85), address of union, structure, pointer, function or another array.
syntex :
	data type arrayname [ arraysize ] = { elements };

Array is useful when:
	1. We have to store large number of data of similar type. If we have large number of similar kind of variable 
		then it is very difficult to remember name of all variables and write the program.
	2. We want to store large number of data in continuous memory location. Array always stores data in continuous memory location.
	3. The number of values between braces { } cannot be larger than the number of elements that we declare for the array
	 between square brackets [ ].
	4. Arrays have 0 as the first index not 1.
	5. If the size of an array is n, to access the last element, (n-1)
	6. Array name is constant pointer and we cannot assign any value in constant data type after declaration.
		eg. 
		char arr[10];
		arr = "world";
	7. Size of any character array cannot be less than the number of characters in any string which it has assigned. 
		Size of an array can be equal (excluding null character) or greater than but never less than.
	8. Size of any array in c cannot be constantan variable but it can be enum const and macro const.
	9. Member of an array cannot be address of auto variable because array gets memory at load time 
		while auto variable gets memory at run time.
	10. If we initialize any array at the time of declaration the compiler will treat such array as static variable 
		and its default value of uninitialized member is zero.

	Note: In any expression lower type data is always automatically type casted into the higher data type.

Advantage of using array:
1. An array provides singe name .So it easy to remember the name of all element of an array.
2. Array name gives base address of an array .So with the help increment operator we can visit one by one all the element of an array.
3. Array has many application data structure.

Array of pointers in c:
	Array whose content is address of another variable is known as array pointers.

QUESTIONS:
        &arr vs arr;
        array vs pointer;
        write your own sizeof operator to get size of an array;
        merge two sorted array into single soretd array where m > n? here m and n are size of corrosponding array's;

strings :
	Strings are actually one-dimensional array of characters terminated by a null character '\0'. 
	Thus a null-terminated string contains the characters that comprise the string followed by a null.

intilization of strings :
using array :
	char c[] = "abcd";
	char c[50] = "abcd";
	char c[] = {'a', 'b', 'c', 'd', '\0'};
	char c[5] = {'a', 'b', 'c', 'd', '\0'};

using pointer :
	char *c = "abcd";

structure :

	struct [structure tag] {
	   member definition;
	   member definition;
	   ...
	   member definition;
	} [one or more structure variables];  

Union :
	union [union tag] {
	   member definition;
	   member definition;
	   ...
	   member definition;
	} [one or more union variables];

Bit field :
	struct < identifier > {
		type member_variable_name: size_in_bits;
	};

	identifier : the name of the bit field that is being declared. 
		The name is optional: nameless bitfields introduce the specified number of bits of padding

	size_in_bits : an integral constant expression with a value greater or equal to zero. 
		When greater than zero, this is the number of bits that this bit field will occupy. 
		The value zero is only allowed for nameless bitfields and has special meaning: 
		it specifies that the next bit field in the class definition will begin at an allocation unit's boundary.
		eg. 
		struct S {
		 // three-bit unsigned field,
		 // allowed values are 0...7
		 unsigned int b : 3;
		};
enum :
	enum identifier <optional> { const1, const2, ..., constN };
	enumerator = constant-expression ;

	identifier, enumerator 	- 	identifiers that are introduced by this declaration
	constant-expression 	- 	integer constant expression whose value is representable as a value of type int
	Here, name of the enumeration is identifier.
	And, const1, const2,...., constN are values of type identfier.
	By default, const1 is 0, const2  is 1 and so on. You can change default values of enum elements during declaration (if necessary).

	#define vs enum; Which one is better? And Why?
	The use of an enumeration constant (enum) has many advantages over using the traditional symbolic constant style of #define. 
	These advantages include a lower maintenance requirement, improved program readability, and better debugging capability.
	1) The first advantage is that enumerated constants are generated automatically by the compiler. Conversely, symbolic 
		constants must be manually assigned values by the programmer.
	2) Another advantage of using the enumeration constant method is that your programs are more readable and thus can be understood 
		better by others who might have to update your program later.
	3) A third advantage to using enumeration constants is that some symbolic debuggers can print the value of an enumeration constant. 
		Conversely, most symbolic debuggers cannot print the value of a symbolic constant. 
		This can be an enormous help in debugging your program, because if your program is stopped at a line that uses an enum, 
		you can simply inspect that constant and instantly know its value. 
		On the other hand, because most debuggers cannot print #define values, you would most likely have to search for that value 
		by manually looking it up in a header file.
	4)enum actually declares a type, and therefore can be type checked.

typedef :
	typedef is a keyword used in C language to assign alternative names to existing types. 
	Its mostly used with user defined data types, when names of data types get slightly complicated.

	typedef existing_name alias_name;
	eg.
	typedef struct member
	{
	  type member1;
	  type member2;
	  type member3;
	} type_name ;

	type_name v1, v2.

	Question:
		#define vs typedef?  
		Consider the two statements below and point out which one is preferred and why?
		#define dPS struct s *
		typedef struct s * tPS;

		dPS p1,p2; => struct s * p1, p2; 
		tPS p3,p4; => struct s * p1,struct s * p2;

	What is the use of typedef?
	i)It increases the portability.
	(ii) It simplify the complex declaration and improve readability of the program.

pointer :
	opertor		precedence		associative
	(), []		1			L -> R
	*, identifier	2			R -> L
	data type	3			

	(): This operator behaves as bracket operator or function operator.
	[]: This operator behaves as array subscription operator.
	*: This operator behaves as pointer operator not as multiplication operator.

	Identifier: It is not an operator but it is name of pointer variable. You will always find the first priority 
	will be assigned to the name of pointer.

	Data type: It is also not an operator. Data types also includes modifier (like signed int, long double etc.)

How to read complex pointer :
	void (*ptr)( int (*)[2], int (*)[3]);
	ptr is pointer to such function which first parameter is pointer to one dimensional array of size two 
	which content int type data and second parameter is pointer to such function which parameter is void 
	and return type is int data type and return type is void.

	int ( * ( * ptr ) [ 5 ] ) ( );
	ptr is pointer to such array of size five which content are pointer to such function 
	which parameter is void and return type is int type data.

	double*(*(*ptr)(int))(double **,char c);
	ptr is pointer to function which parameter is int type data and return type is pointer to function 
	which first parameter is pointer to pointer of double data type and second parameter is char type data type 
	and return type is pointer to double data type.

	Note:
		int *ptr [2];
		int (*ptr)[2];
		int (arr[2]) (const char *, ...);
		struct var arr[2] = { {}, {} };

Rule 1: Arithmetic operation with pointer :
	Address + Number= Address
	Address - Number= Address
	
	Address++ = Address
	Address-- = Address

	++Address = Address
	--Address = Address

	New address = old address + number sizeof(data type) which ponter is pointing.
	New address = old address - number * Size of data type to which pointer is pointing

Rule 2: Difference arithmetic with pointers
	If two pointers are of same type then:
	adr2 - addr1 = ( simple subtraction of two address) / size of data type which pointer points.

Rule 3: Illegal arithmetic with pointers:
	Address + Address=Illegal
	Address * Address=Illegal
	Address / Address=Illegal
	Address % Address=Illegal

Rule 4: Bit wise arithmetic with pointers
	We can perform bit wise operation between two pointers like

	Address & Address=Illegal
	Address | Address=Illegal
	Address ^ Address=Illegal
	~Address=Illegal

Rule 5: We can find size of a pointer using sizeof operator.

tricks :
	*array = *(array +0) = array[0];
	arr[0] = &arr1;
	p[i] = *(p+i) : P[0][0][0]=*(p[0][0]+0)=**p[0]=***p
	*(p+i) = p[i]
	*&i = i
	-> = (*).
	Rule: * and & always cancel to each other
	Note: %s is used to print stream of characters up to null (\0) character.
	Note: Array name gives base address of an array. it is a constant pointer that we can not increment and decrement.
	&arr vs arr;

	Note: Associativity	  ! ~ ++ -- + - (type) * & sizeof      right to left

	ptr++;    // Pointer moves to the next int position (as if it was an array)
	++ptr;    // Pointer moves to the next int position (as if it was an array)
	++*ptr;   // The value of ptr is incremented
	++(*ptr); // The value of ptr is incremented
	++*(ptr); // The value of ptr is incremented
	*ptr++;   // Pointer moves to the next int position (as if it was an array). But returns the old content
	(*ptr)++; // The value of ptr is incremented
	*(ptr)++; // Pointer moves to the next int position (as if it was an array). But returns the old content
	*++ptr;   // Pointer moves to the next int position, and then get's accessed, with your code, segfault
	*(++ptr); // Pointer moves to the next int position, and then get's accessed, with your code, segfault

Generic pointer:
	void pointer in c is known as generic pointer. Literal meaning of generic pointer is a pointer which can point type of data.

Example:
	void *ptr;
	Here ptr is generic pointer.
	1. We cannot dereference generic pointer.
	2. We can find the size of generic pointer using sizeof operator.
	3. Generic pointer can hold any type of pointers like char pointer, struct pointer, array of pointer etc without any typecasting.
	4. Any type of pointer can hold generic pointer without any typecasting.
	5. Generic pointers are used when we want to return such pointer which is applicable to all types of pointers. 
		For example return type of malloc function is generic pointer because it can dynamically allocate the memory space to stores 
		integer, float, structure etc. hence we type cast its return type to appropriate pointer type.

NULL pointer:
	Literal meaning of NULL pointer is a pointer which is pointing to nothing. NULL pointer points the base address of segment.
	Examples of NULL pointer:
	1. int *ptr=(char *)0;
	2. float *ptr=(float *)0;
	3. char *ptr=(char *)0;
	4. double *ptr=(double *)0;
	5. char *ptr=\92\0\92;
	6. int *ptr=NULL;
	
What is meaning of NULL?
	NULL is macro constant which has been defined in the heard file stdio.h, alloc.h, mem.h, stddef.h and stdlib.h as
	#define NULL 0
	We cannot copy any thing in the NULL pointer.

Wild pointer:
	A pointer in c which has not been initialized is known as wild pointer.
	There is difference between the NULL pointer and wild pointer. Null pointer points the base address of 
	segment while wild pointer doesn\92t point any specific memory location.

Dangling pointer:
	If any pointer is pointing the memory address of any variable but after some variable has deleted from that memory location 
	while pointer is still pointing such memory location. Such pointer is known as dangling pointer 
	and this problem is known as dangling pointer problem.
	Solution of this problem: Make the variable as static variable.
	Note: In some compiler you may get warning message returning address of local variable or temporary.

Function :
	Properties :
	1. If function definition has written after the function call then it is necessary to declare the function 
		before the function call because function call statement has no idea about prototype of calling function.

	2.If function definition has written before the function call statement then it is not necessary to write function declaration.
	3.If return type of function is signed int data type then it not necessary to write function declaration 
		even though function definition has written after the function call.
	4.Function\92s declaration doesn\92t reserve any memory space.
	5.In declaration statement it is not necessary to write variable name in parameter of function.
	6. C doesn't support function overloading. In c it is not possible to declare two function of same name 
		but different signatures like number of parameters, data type of parameters, order of parameter etc.

Main function : 
	Properties of main function:
	1. Any c program can have only one main function.
	2. main function is called by operating system.
	3. main is not keyword of c. So any variable name can be main.
	4. Programmer can also call the main function.
	5. Default return type of main function is int and default parameter is void.

	Prototype of main function in c:
	int main (int arg_counter, char *arg_vector[], char *env_vector[]);
	1. Argument counter: 
		First parameter of main function is argument counter. It stores an integer number which is equal to number of parameters 
		passed including file name from the command prompt.
	2. Argument vector: 
		Second parameter of main function is argument vector. It is array which is array of string. 
		This string array contains the actual parameters which have passed from the command prompt.
	3. Environment vector :
		Third parameter of main function is environment variable. It is also array of string which contains 
		all the environments variables of the system.

function declarations : Declaration of function is also known as prototype of a function.
	<return type > <function name> ( < parameters >, ...)

Function defination :
	<return type > <function name > ( < parameters >, ...) {
		/* body */
		statement 1;
		statment 2;
		...
		return [ < expression >];
	}

	Parameter of function can be:
	1. Primitive data type.
	2. Derived data type.
	3. User defined data type.
	4. Ellipsis i.e. variable number of parameter.
	5. We can use modifier with data type in return type.
	Note : parameter cannot be intilized as parameter in function in c.

	How to pass parameters in the function in C :
	Pass by value: 
		In this approach we pass copy of actual variables in function as a parameter. 
		Hence any modification on parameters inside the function will not reflect in the actual variable.
	Pass by reference: 
		in this approach we pass memory address actual variables in function as a parameter. 
		Hence any modification on parameters inside the function will reflect in the actual variable.

	Return type of a function: 
		1. Default return type of function is signed int data type.
		2. Function can return only one value at a time.
		3. Storage classes allowed with return type are static, extern, typedef i.e. we cannot use auto and register storage class 
			with the return type of any function.
		4. Default storage class of return type of a function is extern.
		5. In return type we can use modifier like short, long, signed, unsigned, extern, static, const, volatile etc.

	Return type of function can be:
	1. Primitive data type: Primitive data types are: char, int, float, double, void.
	2. Derived data types are: array, function, pointer.
	3. User defined data types are: structure, union, enum.

How to calculate size of a function in c? 
	Size of function = Size of all local variable which has declared in function + Size of those global variables which 
	has used in function + Size of all its parameter+ Size of returned value if it is an address.

Recursion function :
	Calling of same function from its function body is known as function recursion.It is alternative of loop.
	Any c program which is possible using loop it must be possible using function recursion.

	http://www.cquestions.com/2009/06/function-recursion-in-c-programming.html

	How to write function recursion program in easier way:
	
	Step1: First of all write same program using while loop and function. (Except main function)
	Step 2: In that function make all local variable static.
	Step 3: Replace while keyword by if.
	Step 4: The increment or decrement of variable which is used for condition checking, replace with function call 
		and pass the parameter of that incremented or decremented variable.

	properties :
		1. It is very slow process.
		2. Nature of function recursion is infinite loop or stack over flow.
		3. It follows LIFO data structure.
		4. We can use break keyword in function recursion.
		5. We can not use goto to move the control from one function to another function.

	Declaration vs Defination:
		A declaration introduces an identifier and describes its type. A declaration is what the compiler needs to accept references 
		to that identifier. These are declarations:
			extern int bar;
			extern int g(int, int);
			double f(int, double); // extern can be omitted for function declarations

		A definition actually instantiates/implements this identifier. It's what the linker needs in order to link references 
		to those entities. These are definitions corresponding to the above declarations:
			int bar;
			int g(int lhs, int rhs) {return lhs*rhs;}
			double f(int i, double d) {return i+d;}
		A definition can be used in the place of a declaration.
		An identifier can be declared as often as you want. but can not defined more than one time. read soft and strong symbole concept.
			double f(int, double);
			double f(int, double);
			extern double f(int, double); // the same as the two above
			extern double f(int, double);

	Note : However, identifier must be defined exactly once. If you forget to define something that's been declared and referenced somewhere, 
	then the linker doesn't know what to link references to and complains about a missing symbols. If you define something more than once, 
	then the linker doesn't know which of the definitions to link references to and complains about duplicated symbols. 

. functions can return any type except arrays and functions. We can get around this limitation by returning pointer to array or pointer to function.
. function parameters are always passed by value. Pass-by-reference is simulated in C by explicitly passing pointer values.
. the order of evaluation of func parameters is compiler dependent.
. Name of the function is actually a pointer variable to the function and prints the address of the function. Symbol table is implemented like this.

	struct
	{
	   char *name;
	   int (*funcptr)();
	}
	symtab[] = {
	   "func", func,
	   "anotherfunc", anotherfunc,
	};

. In function defination three continuous dots is known as ellipsis which is variable number of arguments of function. 
	The values to parameters are assigned one by one. Now the question is how to access other arguments. 
	See this for details.
	http://www.geeksforgeeks.org/how-to-count-variable-numbers-of-arguments-in-c/

. by default all function are extern so adding extern doesn’t add anything. 

preprocessors :
	There are two operators in c preprocessor:
		1. # : This operator is called stringizing operator which convert any argument in the macro function in the string. 
			So we can say pound sign # is string maker.	
		2. ## : This operator is called token pasting operator. When we use a macro function with various argument 
			then we can merge the argument with the help of ## operator.

	#if directive in c
	There are total six conditional compilation directives. There are:

	(a)#if
	(b)#elif
	(c)#else
	(d)#endif
	(e)ifdef
	(f)ifndef

	Syntax 1:
	#if <Constant_expression>
	    -------------
	    -------------
	#endif
	If constant expression will return 0 then condition will ture if it will return any non zero number condition will true.

	Syntax 2:
	#if <Constant_expression>
	    -----------------
	    -----------------
	#else
	    -----------------
	    -----------------
	#endif
	Note: Consonant expression in #if condition should not include any c programming variable since all 
		preprocessor directives execute just before the actual c code.
	Note: Constant expression in #if directive cannot be string constant. 
		It can be character constant which returns its ASCII value to directive.

	What is the purpose of the preprocessor directive #error?
	Preprocessor error is used to throw a error message during compile time. We can check the sanity of the make file 
	and using debug options given below

	#ifndef DEBUG
	#ifndef RELEASE
	#error Include DEBUG or RELEASE in the makefile
	#endif
	#endif

	write a MACRO to set the MSB?

	#define cat(x,y) x##y concatenates x to y. But cat(cat(1,2),3) does not expand but gives preprocessor warning. Why?
	The cat(x, y) expands to x##y. It just pastes x and y. But in case of cat(cat(1,2),3), it expands to cat(1,2)##3 instead of 1##2##3. That is 		why it is giving preprocessor warning.
	
	What is the benefit of using #define to declare a constant?
		Using the #define method of declaring a constant enables you to declare a constant in one place and use it throughout your program. 
		This helps make your programs more maintainable, because you need to maintain only the #define statement and not several instances 
		of individual constants throughout your program.
		For instance, if your program used the value of pi (approximately 3.14159) several times, you might want to declare a constant for 
		pi as follows:  #define PI 3.14159
		Using the #define method of declaring a constant is probably the most familiar way of declaring constants to traditional C programmers. 
		Besides being the most common method of declaring constants, it also takes up the least memory.
		Constants defined in this manner are simply placed directly into your source code, with no variable space allocated in memory. 
		Unfortunately, this is one reason why most debuggers cannot inspect constants created using the #define method
		


what Executables contain ?
	two parts: a .data section, containing global variables, and a .text section, containing the actual machine code.
	
static time memory allocation :
		data segment, text segment, bss segment.
	
Runtime memory allocation:
		stack and heap.
   
what is read-only memory. Is that like a flag to the compiler that tells the compiler to do not write into that section?
	char *s = "hello world";
	s[0] = 'd'; /* SEGFAULT */
	the "hello world" is a string literls which actually stored in read-only memory.
	
	char *foo[] = { "bar", "baz", "running out of traditional placeholder names" };
	foo[1][2] = 'n'; /* SEGFAULT */

	That's not a feature of the C language but a feature of the compiler/linker and the operation system working together.

	When you compile such code the following happens:

	. The compiler will put the string into a read-only data-section.

	. The linker collects all the data in such read-only sections and puts them into a single segment. 
	  This segment resides in the executable file and is flagged with a "read only"-attribute.

	. Now comes the operation system executable loader. It loads the executable (or maps it into memory to be more exact). 
	  Once this is done, the loader walks the sections and sets access-permissions for each segment. For a read-only data segment 
	  it will most likely disable code-execute and write access. Code (for example, your functions) gets execute rights but no write access. 
	  Ordinary data like static variables gets read and write access and so on...

Strings as character arrays:
	
	char *str = "GFG"; “GfG” is stored in a read only dtata segment, but pointer str is stored in a read-write memory.
	*(str+1) = 'n'; /* Problem:  trying to modify read only memory */
	You can change str to point something else but cannot change value at present str.
	So this kind of string should only be used when we don’t want to modify string at a later stage in program.
	
	 char *str; 
	 str = "GfG";     /* Stored in read only part of data segment */
	 *(str+1) = 'n'; /* Problem:  trying to modify read only memory */

	char str[] = "GfG"; /*One extra for string terminator*/
	/* Stored in stack segment like other auto variables */
	*(str+1) = 'n';   /* No problem: String is now GnG */
	
	/*    OR    */
	char str[4] = {‘G’, ‘f’, ‘G’, '\0'}; /* '\0' is string terminator */

	Dynamically allocated in heap segment.
	Strings are stored like other dynamically allocated things in C and can be shared among functions.
	char *str;
	int size = 4; /*one extra for ‘\0’*/
	str = (char *)malloc(sizeof(char)*size);
	*(str+0) = 'G'; 
	*(str+1) = 'f';  
	*(str+2) = 'G';  
	*(str+3) = '\0';

problem:
	The below program works perfectly fine as the string is stored in a shared segment and data stored remains there even after return of getString

	char *getString()
	{
	  char *str = "GfG"; /* Stored in read only part of shared segment */
	 
	  /* No problem: remains at address str after getString() returns*/
	  return str;  
	}     
 
	int main()
	{
	  printf("%s", getString());  
	  getchar();
	  return 0;
	}

	This works perfectly fine as the string is stored in heap segment and data stored in heap segment persists even after return of getString()
	char *getString()
	{
	  int size = 4;
	  char *str = (char *)malloc(sizeof(char)*size); /*Stored in heap segment*/
	  *(str+0) = 'G'; 
	  *(str+1) = 'f';  
	  *(str+2) = 'G';
	  *(str+3) = '\0';  
   
	  /* No problem: string remains at str after getString() returns */   
	  return str;  
	}     
	int main()
	{
	  printf("%s", getString());  
	  getchar();
	  return 0;
	}

	But, thismay print some garbage data as string is stored in stack frame of function getString() and data may not be 
	there after getString() returns.
	char *getString()
	{
	  char str[] = "GfG"; /* Stored in stack segment */
 
	  /* Problem: string may not be present after getSting() returns */
	  return str; 
	}     
	int main()
	{
	  printf("%s", getString());  
	  getchar();
	  return 0;
	}

