https://blog.csdn.net/Lonzoc/article/details/50968875
https://blog.csdn.net/pwl999/article/details/79631434
https://blog.csdn.net/STN_LCD/article/details/78846910

DeviceTree (hereinafter abbreviated as DT) is used to describe the device information and the hierarchical relationship between the devices on the bus. DT can be used to describe the details of most board-level devices, including CPU, memory, interrupts, buses, peripherals, etc., related to DT. The Object has dts, dtsi, dtc, dtb, dt.img.

    The dts:DT source file is called the dts file, the Ascii text file, and generally a dts file corresponds to a Machine, and the ARM architecture dts file is stored in the arch/arm/boot/dts/ directory.
    Dtsi: multiple dt files common to Machine/SoC, i stands for include
    Dtc:DeviceTree Compile for compiling dts files into binary dtb files
    Dtb:DeviceTree Bolb, binary target file generated by dtc compiled dts file
    Dt.img: multiple dtb files are packaged to form dt.img to fit multiple Machines. The structure of dts/dtb is standardized. dt.img has header information and multiple dtb components, because there is no uniform standard, different Manufacturer's header information may be different

At present, most Android manufacturers use kernel + ramdisk.img + dt.img packaged into boot.img.

This chapter will detail the following:

    Devicetree file structure
    Devicetree syntax basis
    Devicetree file structure instance resolution
    Device tree compile usage introduction

DTS file structure

The DTS file consists of: root-node, child-node, property, include

    Root-node: Denoted by '/', DT's Entry Point, all devices are in the form of child nodes under the root node
    Child-node: node is in the form of node-name {}; {} is the actual content of the node. The root node is generally a Platform device and a bus. Peripherals exist in the nodes of the bus class in the form of child nodes. In the following example, the cpus node is located under the root node and represents all the CPUs. The cpu0~x nodes are under the cpus and represent all the CPUs on the SoC.
    Property: property, represented as a key-value, in a node
    Include file: used to contain other source files to dts, dtsi general multiple common files in Machine (i stands for include), h files are generally used in dts for macro definition

1. Not all nodes represent actual devices, such as the cpus in the above example.
2. node can also be used to represent Runtime Configuration, such as bootargs, boot address

DeviceTree Compiler (DTC)

DTC is a tool chain for compiling the device tree source file. According to the official introduction, the DTC tool chain converts a file format as input into another file format. A typical input file is a readable dts text file, and the output file is a binary dtb file. Of course, DTC can also use binary dtb file as input and output dts file.

This means that using DTCs can convert dts files and dtb files to each other.

At present DTC supports input formats: dts, dtb, fs; supported output formats are: dtb, dts, asm

The DTC command format is:
dtc [options] [<input_filename>]

Compile dts, generate dtb
 dtc -I dts -O dtb -o output.dtb  file-a.dts file-b.dts 

Decompile dtb, generate dts
dtc -I dtb -O dts -o output.dts  file-z.dtb


Compatible string for device and driver matching
Reg integer indicates the device's address space
Address-cells integer Set the number of cells of the address data in the reg attribute of the child node
Size-cells integer Sets the number of cells of the address length in the reg attribute of the child node
Interrupt-parent reference Specifies the int controller to which the device's interrupt is connected

Skeleton DTSI

Skeleton's role is to define the minimum components required for device startup. It defines the most basic and necessary child-node types for the root-node, usually corresponding to the infrastructure on the SoC such as CPU, Memory, etc.

/*
 * Skeleton device tree in the 64 bits version; the bare minimum
 * needed to boot; just include and add a compatible value.  The
 * bootloader will typically populate the memory node.
 */
/ {
    #address-cells = <2>;
    #size-cells = <2>;
    cpus { };
    soc { };
    chosen { };
    aliases { };
    memory { device_type = "memory"; reg = <0 0 0 0>; };
};

The above Code is from skeleton64.dtsi. The root-node defines a total of 5 basic child-nodes. cpus represents all the CPUs on the SoC. The number of specific CPUs and the parameters are defined in the child-node of cpus. All on-chip peripherals and off-chip peripherals on the platform, such as uart/clock/spi/i2c/display/... These peripherals are defined in other dts/dtsi files; choosen is used to define the runtime configuration; aliases are used to define The alias of node;memory is used to define the physical memory on the device.

Address-cells defines 2 cells in the address space attribute (reg attribute) of all child nodes of the root node to represent the address of the revelation

Size-cells defines the length of the address space by using 2 cells in the address space attribute (reg attribute) of all child nodes of the root node.


specific dts file usually contains multiple dtsi files, roughly divided into the following categories
1. skeleton class dtis - skeleton.dtsi, skeleton64.dtsi
2. pinctrl dtsi - msm8974-pinctrl.dtsi, defines Pin Mux
3. regulator dtsi - msm8974-regulator.dtsi, defines the power supply
4. clock dtsi - msm8974-clock.dtsi, defines the clock signal
5. panel/camera/sensor dtsi - msm8974-mdss-panel.dtsi,msm8974-camera-sensor-xxx.dtsi
6. gpu/ion/leds/xxx


LPIs - devicetree

- 1. Find Devicetree node
1.1 Use the compatible property to find nodes
-------------------------------------------
Starting from the @from node, matching the value of the compatible property of each node with the @compatible string, return
The found devicetree node.

/** 
 * of_find_compatible_node - Find a node based on type and one of the 
 *                                tokens in its "compatible" property 
 * @from: The node to start searching from or NULL, the node 
 * you pass will not be searched, only the next one 
 * will; typically, you pass what the previous call 
 * returned. of_node_put() will be called on it 
 * @type: The type string to match "device_type" or NULL to ignore 
 * @compatibleThe string to match to one of the tokens in the device 
 * "compatible" list. 
 * 
 * Returns a node pointer with refcount incremented, use 
 * of_node_put() on it when done. 
 */  
struct device_node *of_find_compatible_node(struct device_node *from,  
        const char *type, const char *compatible) 

    struct device_node *of_node;  
    /* Searching from root node */  
    of_node = of_find_compatible_node(NULL, NULL, "vendor,chip");  
      
    /* Searching child node from an existing node */  
    struct device_node *parent = of_node; /* node that got from other code*/  
    of_node = of_find_compatible_node(parent, NULL, "vendor,chip");  


1.2 Use the node name to find
/** 
 * of_find_node_by_name - Find a node by its "name" property 
 * @from: The node to start searching from or NULL, the node 
 * you pass will not be searched, only the next one 
 * will; typically, you pass what the previous call 
 * returned. of_node_put() will be called on it 
 * @name: The name string to match against 
 * 
 * Returns a node pointer with refcount incremented, use 
 * of_node_put() on it when done. 
 */  
struct device_node *of_find_node_by_name(struct device_node *from,  
        const char *name) 

Demo:
&i2c1 {  
touchpanel {  
property-a = <1>;  
property-b = "string a";  
};  
};  
  
struct device_node *of_node;  
of_node = of_find_node_by_name(NULL, "touchpanel"); 


Demo:
&i2c1 {  
touchpanel {  
property-a = <1>;  
property-b = "string a";  
};  
};  
  
struct device_node *of_node;  
of_node = of_find_node_by_name(NULL, "touchpanel"); 

1.3 Use phandle to find nodes
/** 
 * of_find_node_by_phandle - Find a node given a phandle 
 * @handle: phandle of the node to find 
 * 
 * Returns a node pointer with refcount incremented, use 
 * of_node_put() on it when done. 
 */  
struct device_node *of_find_node_by_phandle(phandle handle) 

1.4 Finding Nodes by Attribute Name

/** 
 * of_find_node_with_property - Find a node which has a property with 
 *                                   the given name. 
 * @from: The node to start searching from or NULL, the node 
 * you pass will not be searched, only the next one 
 * will; typically, you pass what the previous call 
 * returned. of_node_put() will be called on it 
 * @prop_name:The name of the property to look for. 
 * 
 * Returns a node pointer with refcount incremented, use 
 * of_node_put() on it when done. 
 */  
struct device_node *of_find_node_with_property(struct device_node *from,  
        const char *prop_name)


- 2. Get node properties and values

2.1 Read Shaping Data

int of_property_read_u8(const struct device_node *np,  
        const char *propname, u8 *out_value)  
  
int of_property_read_u16(const struct device_node *np,  
        const char *propname, u16 *out_value)  
  
int of_property_read_u32(const struct device_node *np,  
        const char *propname, u32 *out_value)  
  
int of_property_read_u64(const struct device_node *np,  
        const char *propname, u64 *out_value);

2.2 read integer array

    int of_property_read_u8_array(const struct device_node *np,  
            const char *propname, u8 *out_values, size_t sz)  
      
      
    int of_property_read_u16_array(const struct device_node *np,  
            const char *propname, u16 *out_values, size_t sz)  
          
      
    int of_property_read_u32_array(const struct device_node *np,  
            const char *propname, u32 *out_values, size_t sz)
  
2.3 Read the data of an index position in an integer array
static inline int of_property_read_u32_index(const struct device_node *np,  
        const char *propname, u32 index, u32 *out_value) 

2.4 Reading String Data
int of_property_read_string(struct device_node *np,  
        const char *propname, const char **out_string);  
  
  
int of_property_read_string_index(struct device_node *np,  
        const char *propname, int index, const char **output);  
  
  
int of_property_match_string(struct device_node *np,  
        const char *propname, const char *string);  
  
  
int of_property_count_strings(struct device_node *np,  
        const char *propname)


- 3.Sample Code

#include <linux/of.h>
    static int samp_parse_dts(struct device *dev)  
    {  
        struct device_node *of_node = dev->of_node;  
        const char *compatible = "vendor,x";  
        u32 val0;  
        u8 val1;  
        const char *string;  
      
        if (!of_node)  
            return -EINVAL;  
      
        if (!of_device_is_compatible(of_node, compatible))  
            return -ENODEV;  
      
        if (of_property_read_u32(of_node, "vendor,val0", &val0))  
            /* fail */  
            val0 = -1;  
      
        if (of_property_read_u8(of_node, "vendor,val0", &val1))  
            /* fail */  
            val1 = -1;  
      
        if (of_property_read_string(of_node, "vendor,str", &string)  
            string = NULL;  
        return 0;  
    }  

